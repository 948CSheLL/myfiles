### 1、A Tutorial Introduction

- 书中的一些比较总结性的话：

  - 一个C语言程序，是由**函数**和**变量**组成的，其中函数中包括一些**语句**，来指定要执行的计算操作。

  - 函数之间进行**数据交换的一种方法**是调用函数向被调用的函数提供一个值。

  - C语言中，所有**变量都必须先声明后使用**。

  - 不同的机器，int、char、short、long、double和float等数据类型的取值范围不一定相同，有的机器上int是32位，有的是16位。

  - `printf`函数是一个**通用输出格式化函数**，第一个参数是一个格式化的字符串，其中的`%`分别对应于第二个参数，第三个参数......，他们在数目上都必须相匹配，否则将出现错误的结果。

    `printf`函数支持下面的**格式**：

    - `%o`表示八进制数。
    - `%x`表示十六进制数。
    - `%c`表示字符。
    - `%s`表示字符串。
    - `%d`表示十进制整数。
    - `%f`表示浮点数。
    - `u`表示无符号整数。

  - 如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前**整型操作数将被转换为浮点型**。

  - C语言中的**一条通用的原则**：在允许使用某种类型变量值的任何场合，都可以使用该类型的更为复杂的表达式。

  - 在程序中使用300、20等类似的幻数并不是一个好习惯（这种数通常不能直观的理解其含义），可以使用`#define`来将这些数定义成**符号常量**，如下：

    ```c
    #define ONE 1
    ```

    符号常量名通常是大写字母。如果程序中的幻数都以符号常量的形式出现，对程序进行大量修改就会相对容易很多。

  - **C语言标准库提供的输入输出流模型是**：文本流是由多行字符构成的字符序列，而每行字符则有0个或多个字符组成，行末是一个换行符。

  - 字符型数据既可以用`char`类型来存储，也可以用`int`类型来存储。

  - 单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，一般称之为字符常量，这种单引号中的字符只是小的整数的另一种写法，相当于是一个符号常量。

  - `%.0f`强制**不打印**小数点和小数部分，因此小数部分位数位0。

  - 数组下标可以是任何整数表达式，包括整型变量以及整型常量。

  - `char`类型的字符是小整型，因此`char`类型的变量和常量在算术表达式中等价于`int`类型的变量和常量。

  - C语言中**`main`函数也会向其调用者返回一个值**，该**调用者**实际上就**是程序的执行环境**，一般的，返回值为0表示正常终止，非0表示出现了异常或出错。

  - `main`函数之前的函数声明语句是**函数原型**，如下所示：

    ```c
    int power(int m, int n)
    ```

    函数原型与**函数声明中参数名**不要求完全相同，**甚至可以不写**，不过参数名可以起到很好的说明作用。

  - C语言中，所有函数的参数都是通过值来进行传递的，**传递给被调用函数的参数存放在临时变量**中，而不是存放在原来的变量中。

  - C语言中，**被调函数**不能直接修改主调用函数中变量的值，而**只能修改其私有的临时副本的值**。

    如果要让被调函数直接修改主调函数中变量的值，需要**将被调函数中的参数声明为指针类型**，之后主调函数**将变量的地址传入**给被调函数，从而通过指针来间接访问变量。

  - 函数中的每个局部变量只在函数被调用的时候存在，在函数执行完毕退出时消失，由于这种特性，**局部变量又被成为自动变量**，如果自动变量没有被赋值，那么其保存的是无效值。

    除了自动变量外，还可以定义位于**所有函数外部的变量**（只能定义一次），外部变量在程序执行期间一直存在。外部变量定义之后**编译程序将为它分配存储单元**。

    每个需要访问外部变量的函数，都必须声明相应的外部变量，说明其类型，声明时可以用`extern`语句显式声明，也可以通过上下文隐式声明，如下：

    ```c
    #include <stdio.h>
    
    int maxn = 256;
    int main() {
        extern int maxn;
        printf("%d\n", maxn);
        return 0;
    }
    ```

  - 定义和声明的区别：

    - 定义：表示创建变量，即将变量名和一块内存空间相关联。
    - 声明：只是说明变量的性质，并不分配内存空间。

    关于定义和声明详见`https://blog.csdn.net/chengde6896383/article/details/82428676`。

- 关于`extern`关键字的说明：

  - `extern`关键字是进行变量的声明的，所以使用`extern`修饰的变量不能被初始化。

    ```c
    extern int temp;
    ```

    正确；

    ```c
    extern int temp = 3;
    ```

    错误。

  - `extern`一般用来修饰外部变量（即，在所有函数之外的变量，全局变量），因为函数在使用外部变量之前需要知道外部变量的名字，因此需要在使用前先对其进行声明。

    ```c
    #include <stdio.h>
    
    int main() {
        extern int extern_var;
        printf("%d\n", extern_var);
        return 0;
    }
    
    int extern_var = 333;
    ```

    某些情况下可以省略`extern`的声明，比如，外部变量的定义与要使用这个外部变量的函数在同一个源文件中，且外部变量的定义在函数定义之前，这种情况就可以不用extern来修饰外部变量。

    ```c
    #include <stdio.h>
    
    int extern_var = 333;
    
    int main() {
        // extern int extern_var;
        printf("%d\n", extern_var);
        return 0;
    }
    ```

  - 如果一个文件包含多个源文件（注意，这里的源文件是指后缀为`.c`的文件，后缀为`.h`的文件此处成为头文件），文件file1.c中定义了一个全局变量，file2.c中如果要使用这个变量，就需要在file2.c文件中对file1.c中定义的全局变量进行声明。

    ```c
    /* file1.c */
    int tmp_extern = 111;
    ```

    ```c
    /* file2.c */
    #include <stdio.h>
    
    int main() {
        // 下面需要打印file1.c中的全剧变量tmp_extern
        extern int tmp_extern;
        printf("%d\n", tmp_extern);
        return 0;
    }
    ```

    如果是在`Ubuntu 18.04`环境下，之后只需要运行命令`gcc file1.c file2.c ; ./a.out`就能够输出结果了。

  - 如果一个文件file2.c要是用file1.c中定义的全局变量或者函数，一般的习惯是用`extern`声明file1.c中的全局变量和函数，并将`extern`语句移到一个头文件file2.h中，之后只需要在file2.c文件的开始处添加一条`#include "file2.h"`就能够使用file1.c中的全局变量和函数了。

    ```c
    /* file1.c */
    int tmp_extern = 111;
    ```

    ```c
    /* file2.h */
    #ifndef _FILE2_H
    #define _FILE2_H
    
    extern int tmp_extern;
    
    #endif
    ```

    ```c
    /* file2.c */
    #include <stdio.h>
    #include "file2.h"
    
    int main() {
        // 下面需要打印file1.c中的全剧变量tmp_extern
        printf("%d\n", tmp_extern);
        return 0;
    }
    ```

    如果是在`Ubuntu 18.04`环境下，之后只需要运行命令`gcc file1.c file2.c file2.h; ./a.out`就能够输出结果了。

- 关于不同类型的指针相互强制转换的说明：

  变量的值是以二进制形式存储在内存中的，每个内存字节对应一个内存地址，而内存存储的值本身是没有整型，指针，字符等的区别的，区别的存在是因为我们对它们有不同的解读。c编译器会根据c代码中变量的类型，**从指针所指的内存位置**开始取出内存中一定字节的数据进行运算，**具体是取出多少字节，和变量的类型有关**，比如，如果是32位int类型，那么将会取出4bytes的数据。通过下面的代码进行分析。

  ```c
  #include <stdio.h>
  
  struct type
  {
      int a;
      char s[99];
  };
   
  int main() {
      char* s = "abcdefghijkl";
      struct type *p = (struct type *)s;
      printf("%d %s\n", p -> a, p -> s);
      return 0;
  } 
  
  /* 输出如下：
  1684234849 efghijkl
  */
  ```

  上面的代码是所做的事情是将一个字符指针的类型强制转变成`struct type *`这种结构体指针类型（通用一点儿的语法为：`struct 结构体名 * = (结构体名 *)某个变量的地址值`），由于根据`type`这个结构体的定义，第一个成员是一个`int`类型的变量，因此`p -> a`语句会从原指针`s`的所指位置向后提取4字节的数据，将这4字节的数据进行计算，变成一个`int`值，原指针`s`所指的前4个字符是`abcd`，因此在内存中存储的值为`01100100 01100011 01100010 01100001`（从高地址 -> 低地址），转变成`int`值就是`1684234849`，对于成员s，会在原指针`*s`的基础上向后偏移4个bytes的地址之后开始取值，所以取出的值为`efghijkl`。

  其实任何指针类型的强制转换都大同小异，只要分清楚存储某个变量需要多少字节就能够把思路理清楚。

### 2、Types, Operators and Expressions

- 书中的一些比较有总结的话：

  - C语言**只提供了下列几种基本数据类型**：

    - `char`，字符型，占1byte，可以存放一个字符。
    - `int`，整型，不同的机器占用的字节数不同。
    - `float`，单精度浮点型。
    - `double`，双精度浮点型。

    此外，可以在这些基本数据类型前面加上一些限定符：`short`、`long`、`signed`和`unsigned`。

    **类型长度应该遵循下面的限制**：

    - `short`和`int`类型至少是16位；
    - `long`类型至少是32位；
    - `short`类型不得长于`int`类型；
    - `int`类型不得长于`long`类型。

    **`unsigned`类型的数总是非负的**，并遵循模`2^n`定律，其中n是该类型占用的位数，比如：

    - `unsigned char`类型变量的取值范围为`0~255`；
    - `signed char`类型变量的取值范围为`-128~127`；
    - 不带限定符的`char`类型对象是否带符号则取决于具体机器，不过**可打印字符总是正值**。

  - **常量表达式**是仅仅包含常量的表达式，这种表达式**在编译时求值**，而**不在运行时求值**。

  - 字符串常量就是字符数组，存储字符串的**物理存储单元数比括号在双引号中的字符多一个**，多的这一个是末尾的结束符`\0`。

  - **取模运算符`%`，不能**应用于`float`或`double`类型。

  - 当一个运算符得几个操作数类型不同时，需要通过一些规则把它们转换为某种共同的类型，一般来说，**自动转换**是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息。

    一般来说，如果二元运算符的两个操作数具有不同的类型，那么在进行**运算之前先要把“较低”的类型提升为“较高”类型**，**运算结果为较高的类型**。详细的规则可以看**书上的附录A.6**，不过如果没有`unsigned`类型的操作数，则**使用下面这些非正式的原则**就可以（严格按照从上到下的顺序进行匹配，匹配到一个就不接着匹配了）：

    - 如果一个操作数类型是`long double`，那么将另一个操作数转换为`long double`；
    - 如果一个操作数是`double`，则将另一个操作数转为`double`。
    - 如果一个操作数是`float`，则将另一个操作数`float`。
    - 如果一个操作数是`long`，则将另一个操作数转成`long`。
    - 将`char`与`short`类型的操作数转换为`int`类型。

    当表达式中**含有`unsigned`类型的操作数**时，转换规则会**比较的复杂**，主要原因在于**带符号值与无符号值之间的比较**运算与机器有关，**取决于机器中不同整数类型的大小**，比如（假设`int`为16位，`long`为32位）：

    - `-1L < 1U`这是因为`unsigned int`类型的`1U`被提升为`signed long`类型；
    - `-1L > 1UL`这是因为`signed long`类型的`-1L`被提升为`unsigned long`类型，变成了一个非常大的整数，因此比`1UL`更大了。

  - 赋值运算符右边的值需要转换为左边变量的类型。

  - 如果调用函数的参数为`char`或`float`类型，在声明函数的时候也应该将参数的类型声明成较宽的类型，比如`int`或`double`。**这样做可以有效地防止精度的丢失**。

  - 在任何表达式中都可以使用一个**强制类型转换**的一元运算符强制进行显式类型转换，格式如下：

    ```c
    (类型名) 表达式
    ```

  - C语言中的6个**位操作**运算符**只能作用于**整型操作数，即有符号或者无符号`char`、`short`、`int`与`long`类型。

    - 与运算经常用来屏蔽某些二进制位，即将一个整数某些位变成0；
    - 或运算经常用来将某些二进制位变成1。

  - 在对`unsigned`类型的**无符号值进行右移时**，左边空出的部分将用**0来填补**；

    在对`signed`类型的**带符号值进行右移**时，**某些机器将**对左边空出的部分**用符号位填补**（即，算术移位），而另一些机器则对左边空出的部分**用0填补**（即，逻辑移位）。

  - **表达式`x &= (x-1)`**可以将原数值`x`右边第一个等于1的位变成0，比如数值3，二进制值为11，进行了运算之后，二进制值变成了10，即数值2。

- C语言会自动将两个相邻双引号中的字符串合并到一起，如下：

  ```c
  #include <stdio.h>
  
  int main() {
      char *s = "hello, " "world!";
      printf("%s\n" "end", s);
      return 0;
  }
  
  /* output
  hello, world!
  end
   * /
  ```

- 枚举常量是另一种类型的常量，**枚举是一个常量整型值得列表**；在**没有显示说明的情况**下，`enum`类型中第一个枚举名的值为0，第二个为1，以此类推，此时如下；

  ```c
  #include <stdio.h>
  
  int main() {
      enum boolean {NO, YES};
      printf("first enum member: %d\n", NO);
      printf("second enum member: %d\n", YES);
      return 0;
  }
  
  /* output
  first enum member: 0
  second enum member: 1
  */
  ```

  **如果只指定了部分枚举名的值，那么未指定值的枚举名得值将依照最后一个指定值向后递增，每次递增1**，测试如下；

  ```c
  #include <stdio.h>
  
  int main() {
      enum days {mon = 1, tur = 2, wed, th, fri, sat, sun};
      printf("first enum member: %d\n", mon);
      printf("second enum member: %d\n", tur);
      printf("third enum member: %d\n", wed);
      printf("fourth enum member: %d\n", th);
      printf("fifth enum member: %d\n", fri);
      printf("sixth enum member: %d\n", sat);
      printf("seventh enum member: %d\n", sun);
      return 0;
  }
  
  /* output
  first enum member: 1
  second enum member: 2
  third enum member: 3
  fourth enum member: 4
  fifth enum member: 5
  sixth enum member: 6
  seventh enum member: 7
  */
  ```

  不同枚举中的名字必须互不相同，测试如下；

  ![image-20210706202413409](D:\for_wps\WPS Cloud Files\typora_imags\image-20210706202413409.png)

  从上图可以看出如果不同的枚举变量定义了相同得成员名，那么会报错。

  **同一枚举中不同的成员可以具有相同的值**，测试如下；

  ```c
  #include <stdio.h>
  
  int main() {
      enum enum1 {member1 = 1, member2 = 1};
      printf("first enum member: %d\n", member1);
      printf("second enum member: %d\n", member2);
      return 0;
  }
  
  /*
  first enum member: 1
  second enum member: 1
  */
  ```

- 打印自己电脑上分别由signed和unsigned限定的char、short、int、long类型变量的取值范围（对应练习2-1），程序如下：

  ```c
  #include <stdio.h>
  #include <limits.h>
  
  int main() {
      printf("unsigned char max: %lu\n", UCHAR_MAX);
      printf("unsigned char min: %lu\n", 0);
      printf("unsigned int max: %lu\n", UINT_MAX);
      printf("unsigned int min: %lu\n", 0);
      printf("unsigned long max: %lu\n", ULONG_MAX);
      printf("unsigned long min: %lu\n", 0);
      printf("unsigned short max: %lu\n", USHRT_MAX);
      printf("unsigned short min: %lu\n", 0);
  
  
      printf("signed char max: %d\n", SCHAR_MAX);
      printf("signed char min: %d\n", SCHAR_MIN);
      printf("signed int max: %d\n", INT_MAX);
      printf("signed int min: %d\n", INT_MIN);
      printf("signed long max: %ld\n", LONG_MAX);
      printf("signed long min: %ld\n", LONG_MIN);
      printf("signed short max: %d\n", SHRT_MAX);
      printf("signed short min: %d\n", SHRT_MIN);
      return 0;
  }
  
  ```

- 关于`printf`函数将一个char类型、值为负数的变量强制转换成int和long类型进行输出，值一个为负（正确的值），一个为正（错误的值）的说明：

  程序如下：

  ```c
  #include <stdio.h>
  
  int main() {
      char c = -1;
      printf("int type value: %d\n", c);
      printf("long type value: %ld\n", c);
      return 0;
  }
  
  /* output
  int type value: -1
  long type value: 4294967295
  */
  
  ```

  

  我的机器上char类型变量占1byte，在存储负值的时候以补码的形式存储在内存中，按照常理来说存储在内存中的应该是`1000 000`但是，经过测试，存储在内存中的是`1111 1111 1111 1111 1111 1111 1000 0000`，这样的话强制用int输出是不会有错的，而强制用long输出会被解析为`0000 0000 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111 1111 1111 1000 0000`，这样就变成了正数4294967295了。

  **总结：如果要使用`printf`函数将一个低精度类型强制用高精度格式输出，应该加上强制类型转换，不然会出现解析错误。**如下：

  ```c
  #include <stdio.h>
  
  int main() {
      char a = -1;
      printf("%ld\n", (long)a);
      return 0;
  }
  ```

### 3、Control Flow

- 关于switch语句的总结：

  switch语句的语法如下：

  ```c
  switch(表达式) {
      case 常量表达式1: 语句序列
      case 常量表达式2: 语句序列
      default: 语句序列
  }
  ```

  其中，switch语句中的表达式的类型以及case中的常量表达式的类型必须是整数类型，如果试着传入一个浮点数，会报错。

  如果想让不同的case执行相同的语句序列，可以使用形如下面的switch语句：

  ```c
  switch(i) {
      case 0:
      case 1:
      case 2:
      cout<<"Hello world!"<<endl;
  }
  //当i=0,1,2时，都有相同的输出。
  ```

- 标准库中提供了一个更完善的函数`strtol`，将字符串转换为长整型。可以通过`man strtol`来查看其功能。

- C语言中除了`while`和`for`这两种循环语句之外，还提供了`do-while`循环。`do-while`在循环体执行后测试终止条件，这样循环体至少被执行一次，`do-while`语法形式如下。

  ```c
  do {
      循环体
  } while(表达式);
  ```

- `break`语句能使程序从`switch`或最内层循环中立即跳出。

### 4、Functions and Program Structure

- 书中的一些比较有总结的话：

  - 函数的定义形式如下：

    ```c
    返回值类型 函数名(参数声明表) {
        声明和语句
    }
    ```

    函数定义中的各构成部分可以省略，最简单的函数如下所示：

    ```c
    dummy() {}
    ```

    **只要有`{}`就是函数定义，没有的话就是函数声明。**上面的函数不执行任何操作也不返回任何值，这种不执行任何操作的函数有时很有用，它可以在程序开发期间用以保留位置。**如果函数定义中省略了返回值类型，则默认为`int`类型**。

    被调用函数通过`return`语句向调用者返回值，`return`语句的后面可以跟任何表达式，如下：

    ```c
    return 表达式;
    ```

    在必要时，**表达式将被转换为函数的返回值类型**。

    调用函数可以忽略返回值，`return`语句后面也不一定需要表达式，当`return`语句的后面没有表达式时，函数将不向调用者返回值。

    **一个好的建议**：如果函数中带有参数，则要对他们进行声明，如果没有参数，则使用`void`进行声明，如下所示：

    ```c
    fuc(void);
    ```

  - 如果函数之间需要共享大量的变量，使用外部变量要比使用一个很长的参数表更方便。不过这么做要非常谨慎，这可能会导致程序中各个函数之间具有太多的数据联系。

    **使用外部变量作为函数间的共享数据的一种情况是**：函数之间不相互调用对方，但都需要使用一些相同的参数。

  - 构成c语言程序的函数与外部变量可以分开进行编译，一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载。

  - 外部变量或函数的作用域从声明它的地方开始到其所在的文件的末尾结束。

    在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过`extern`声明来访问它。外部数组变量的定义中必须指定数组的长度，但`extern`声明则不一定要指定数组长度。

  - 外部变量的声明与定义严格区分开来很重要，变量声明用于说明变量的属性（变量的类型），而变量定义除此以外还将引起存储器的分配。

  - **一个好的建议**：可以尽可能将共享的部分集中在一起，这样就可以只需要一个副本，在改进程序的时候容易保证程序的正确性。

    对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象，较大的程序需要使用更多的头文件，我们需要精心的组织他们。

  - 要将对象指定为静态存储，可以在正常的对象声明之前加上关键字`static`作为前缀。

    用`static`限定外部变量与函数，**可以将其后声明的对象的作用域限定为其定义的文件中**。将对象指定为静态存储的**优点**：可以降藕，用`static`声明的变量不会和同一程序中的其他文件中的相同的变量名相冲突。

    外部`static`声明通常用于变量，但也可以用于函数，含有`static`关键字的函数只对该函数声明所在的文件中可见，其他文件是无法访问的。

    `static`也可用于声明内部变量，`static`类型的内部变量同自动变量一样，但与自动变量不同的是：不管其所在的函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失，`static`类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。

    静态变量只在第一次进入程序块（即，`{}`）时被初始化一次。

    在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值则没有定义（即，初值为无用的信息）。对于外部变量和静态变量来说，初始化表达式必须是常量表达式，且只初始化一次，对于自动变量与寄存器变量来说，则在每次进入函数或程序块（即，`{}`）时都将初始化，初始化表达式可以不是常量表达式，表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。

  - `register`声明告诉编译器，他所声明的变量在程序中的使用频率较高，将`register`变量放在机器的寄存器中，这样可以使程序更小、执行速度更快，`register`声明只适用于自动变量以及函数的形式参数，如下所示：

    ```c
    f(register unsigned m, register long n) {
        register int i;
    }
    ```

    每个函数只有很少的变量可以保存在寄存器中，且只允许某些类型的变量，但是过量的寄存器声明并没有什么害处，这是因为编译器可以忽略过量的或不支持寄存器变量的声明。
    
  - 变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其他标识复合语句开始的左花括号之后，以这种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左括号匹配的右花括号出现之前一直存在。

    **一个好的建议**：应该避免出现变量名隐藏外部作用域中相同名字的情况（即，出现相同的变量名），否则可能引起混乱和错误。

  - 数组的初始化是在声明的后面紧跟一个初始化表达式列表，初始化列表用花括号括起来，各初始化表达式之间通过逗号分隔，比如各个月份天数：

    ```c
    int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    ```

    当省略数组长度时，编译器将把花括号中初始化表达式的个数作为数组的长度。

    如果初始化表达式的个数比数组元素数目少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0。

    如果初始化表达式的个数比数组元素数目多，则**是错误的**。

    不能一次将一个初始化表达式指定给多个数组元素，也不能跳过前面的数组元素而直接初始化后面的数组元素。

    字符数组的初始化比较特殊，可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列，如下：

    ```c
    char pattern[] = "ould";
    // 等价于
    char pattern[] = {'o', 'u', 'l', 'd', '\0'};
    ```

    上面的数组长度是5，因为还要加上一个字符串结束符。

  - 关于递归的优缺点简述：

    优点：递归编写的代码比较紧凑，并且相应的非递归代码更容易编写与理解。

    缺点：递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈，递归的执行速度并不快，但递归代码比较紧凑。

  - 关于C预处理器的说明：

    从概念上讲，预处理器是编译过程中单独执行的第一个步骤，两个最常用的预处理器指令是`#include`指令和`#define`指令。

    在源文件中，任何形如`#include "文件名"`或`#include <文件名>`的行都将被替换为由`文件名`指定的文件的内容，如果`文件名`用引号引起来，则在源文件所在位置查找该文件，如果在该位置没有找到文件，或者说`文件名`用尖括号括起来，则将根据相应的规则查找该文件，这个规则和具体的实现有关。

    源文件的开始处通常都会有多个`#include`指令，用以包含常见的`#define`语句和`extern`声明，或从头文件中访问库函数的函数原型声明。

    在大的程序中，`#include`指令是将所有声明捆绑在一起的较好方法，它保证所有的源文件都具有相同的定义于变量声明。

    宏定义的形式如下：

    ```c
    #define 名字 替换文本
    ```

    上面的是一种最贱的的宏替换，后续所有出现`名字`记号的地方都将被替换为`替换文本`，`#define`指令中的`名字`与变量名的命名规则相同，`替换文本`可以是任意字符串。`#define`指令定义的名字的作用域从其定义点开始，到被编译的源文件的末尾处结束，宏定义中也可以使用前面出现的宏定义，**替换只对记号进行，对括在引号中的字符串不起作用**。

    替换文本可以是任意的，如下：

    ```c
    #define forever for(;;)
    ```

    宏定义还可以带参数，如下：

    ```c
    #define max(A, B) ((A) > (B) ? (A) : (B))
    ```

    语句`x = max(p + q, r + s)`将被替换为`x = ((p + q) > (r + s) ? (p + q) : (r + s))`，**不过**，如果是语句`max(i++, j++)`的话就不会正确了，根据上面的宏定义，它将对每个参数执行两次自增操作。同时还必须注意，要适当使用圆括号以保证计算次序的正确性，就拿下面的宏来举例：

    ```c
    #define square(x) x * x
    ```

    上面的宏定义对于语句`square(z + 1)`来说是不正确的，此语句会被替换为`z + 1 * z + 1`，存在逻辑错误，**因此最好给宏定义替换文本中的参数加上括号**。

    可以通过`#undef 名字`来取消名字的宏定义。

    宏定义中的参数不能用带引号的字符串替换，但是，如果在替换文本中参数名以`#`作为前缀，则结果将被扩展为由实际参数替换该参数的带引号的字符串，比如如下：

    ```c
    #define dprint(expr) printf(#expr " = %g\n", expr)
    ```

    使用语句`dprint(x/y)`将被扩展为`printf("x/y" " = %g\n", x/y)`。

    预处理器运算符`##`为红扩展提供了一种连接实际参数的手段，宏定义如下：

    ```c
    #define paste(front, back) front ## back
    ```

    使用宏调用`paste(name, 1)`的结果将创建记号`name1`。测试如下：

    ```c
    #include <stdio.h>
    
    #define paste(front, back) front ## back
    #define debug(expr) printf(# expr " = %d\n", expr)
    
    
    int main() {
        int firstsecond = 1;
        debug(paste(first, second));
        return 0;
    }
    
    /*
    paste(first, second) = 1
    */
    ```

    例子：定义宏`swap(t, x, y)`以交换`t`类型的两个参数（练习4-14）：

    ```c
    #include <stdio.h>
    
    #define swap(t, x, y) { t tmp; tmp = x; x = y; y = tmp; }
    
    
    int main() {
        int x = 1, y = 2;
        printf("x = %d, y = %d\n", x, y);
        swap(int, x, y);
        printf("after swap x and y:\n");
        printf("x = %d, y = %d\n", x, y);
        return 0;
    }
    
    
    /*
    x = 1, y = 2
    after swap x and y:
    x = 2, y = 1
    */
    ```

    `#if`语句对其中的常量整形表达式（其中不能包含`sizeof`、类型转换运算符或`enum`常量），进行求值，若该表达式的值不等于0，则包含其后的各行，直到遇到`#endif`、`#elif`或`#else`语句为止；在`#if`语句中可以使用表达式`defined(名字)`，该表达式的值遵循下列规则：当`名字`已经定义时，其值为`1`，否则，其值为`0`，比如：

    ```c
    #if !defined(HDR) // 等同于 ifndef HDR
    #define HDR
    
    /* hdr.h文件的内容放在这里 */
    
    #endif
    ```

    上面的这种方式可以用来避免多次重复包含同一文件。

    
