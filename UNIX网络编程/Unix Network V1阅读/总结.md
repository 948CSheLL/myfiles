### 1、Introduction

- 查询`errno`变量的值对应的错误可以通过命令`vim /usr/include/asm-generic/errno.h`来进行查询。

- 为了查询方便查询，下面将本书中的时间客户端-服务端程序放在下面：

  - 客户端程序：

    ```c
    #include	"unp.h"
    
    int
    main(int argc, char **argv)
    {
    	int					sockfd, n;
    	char				recvline[MAXLINE + 1];
    	struct sockaddr_in	servaddr;
    
    	if (argc != 2)
    		err_quit("usage: a.out <IPaddress>");
    
    	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    		err_sys("socket error");
    
    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family = AF_INET;
    	servaddr.sin_port   = htons(13);	/* daytime server */
    	if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
    		err_quit("inet_pton error for %s", argv[1]);
    
    	if (connect(sockfd, (SA *) &servaddr, sizeof(servaddr)) < 0)
    		err_sys("connect error");
    
    	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) {
    		recvline[n] = 0;	/* null terminate */
    		if (fputs(recvline, stdout) == EOF)
    			err_sys("fputs error");
    	}
    	if (n < 0)
    		err_sys("read error");
    
    	exit(0);
    }
    ```

  - 服务端程序：

    ```c
    #include	"unp.h"
    #include	<time.h>
    
    int
    main(int argc, char **argv)
    {
    	int					listenfd, connfd;
    	struct sockaddr_in	servaddr;
    	char				buff[MAXLINE];
    	time_t				ticks;
    
    	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
    
    	bzero(&servaddr, sizeof(servaddr));
    	servaddr.sin_family      = AF_INET;
    	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    	servaddr.sin_port        = htons(13);	/* daytime server */
    
    	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
    
    	Listen(listenfd, LISTENQ);
    
    	for ( ; ; ) {
    		connfd = Accept(listenfd, (SA *) NULL, NULL);
    
            ticks = time(NULL);
            snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
            Write(connfd, buff, strlen(buff));
    
    		Close(connfd);
    	}
    }
    ```

- **连接的TCP socket每一个Tcp socket在内核中都有一个发送缓冲区和接收缓冲区，TCP的全双工的工做模式以及TCP的流量(拥塞)控制都是依赖于这两个独立的buffer。**

### 2、The Transport Layer:TCP, UDP, and SCTP

- 为了方便起见，下面附上一个SCTP四次握手建立连接的图（Figure 2.6）：

  ![image-20210731171444898](D:\for_wps\WPS Cloud Files\typora_imags\image-20210731171444898.png)

- 为了方便起见，放上一个IPv4和IPv6的报头的结构，如下所示：

  - IPv4：

    ![image-20210615221526973](D:\for_wps\WPS Cloud Files\typora_imags\image-20210615221526973.png)

  - IPv6：

    ![image-20210615221657089](D:\for_wps\WPS Cloud Files\typora_imags\image-20210615221657089.png)

- 为了方便查询，下面附上一个端口号分配的表（Figure 2.10 Allocation of port numbers.）：

- ![image-20210616094653263](D:\for_wps\WPS Cloud Files\typora_imags\image-20210616094653263.png)

- 为了方便查询，把TCP状态转换图放在下面（Figure 2.4）：

  ![image-20210616142856755](D:\for_wps\WPS Cloud Files\typora_imags\image-20210616142856755.png)

- 为了方便查询，附上一个TCP三次握手和四次挥手全过程的图（Figure 2.5 Packet exchange for TCP connection）。

  ![image-20210616144557575](D:\for_wps\WPS Cloud Files\typora_imags\image-20210616144557575.png)

  设置TIME_WAIT状态来维护连接状态有两个原因：

  - 让TCP全双工连接的终止更加的可靠：如果主动结束的一方，在四次挥手的第四步发送的ACK丢失了，那么被动结束的一方会重传FIN，**若没有这个状态**（即之前的连接信息已经不存在了），那么主动结束方会给被动结束方发送RST报文，被动结束方会将这个报文当作一个错误来处理，**双方的连接并没有正常结束**；**有这个状态**（即维持着连接状态，保有连接信息），就算是主动方最后的ACK丢失了，被动方重传了FIN，主动结束方收到了被动方的重传的FIN之后，依然可以给被动方回复一个ACK，**这样双方的连接依然可以正常结束**。
  - 避免短时间的重复连接：TCP不允许客户端的IP和端口与服务端的IP和端口在连接断开之后在很短的时间又建立连接，这是两个的不同的TCP连接，但是给人的感觉却像是同一个TCP连接，所以通过设置TIME_WAIT状态可以保证在2MSL的时间内不会出现重复的TCP连接被建立，因为**客户端和服务端发送的数据段的存活时间最多是MSL**，故**在2MSL的时间内**，两者**发送的数据段一定会被丢掉**，因此这就保证了在2MSL的时间内不会出现重复的连接。

- 通过Linux中的`telnet`命令连接主机中由守护进程`inetd`提供的`daytime`服务：

  具体的操作过程如下：

  首先先下载`xinetd`：

  ```shell
  sudo apt-get install xinetd
  ```

  以`root`的身份修改文件`/etc/xinetd.d/daytime`，将文件中的两个`disable`选项的值由`yes`改成`no`。

  ```shell
  sudo vim /etc/xinetd.d/daytime
  ```

  ![image-20210621092108985](D:\for_wps\WPS Cloud Files\typora_imags\image-20210621092108985.png)

  之后重启守护进程（守护进程是一个服务）

  ```shell
  sudo /etc/init.d/xinetd restart
  ```

  这下子就能够执行成功执行了，如下图：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\run_inetd_daytime.gif)

  PS：守护进程提供的服务如下：

  ```shell
  testvim@ubuntu:~$ l /etc/xinetd.d
  chargen       daytime-udp   echo       servers    time-udp
  chargen-udp   discard       echo-udp   services
  daytime       discard-udp  '$HOME'/    time
  ```
  
  **PPS：**每修改一次服务文件之后都需要重启`xinetd.d`服务。

### 3、Sockets Introduction

- value-result参数：概括地说是一个变量既是一个函数的参数又是一个函数的返回值（将一个变量作为参数传入到某个函数中，在这个函数中对这个参数进行处理使其值发生了变化，之后并将这个参数进行返回，这样的参数就是value-result参数）。

- IPv4、IPv6的地址结构的长度分析：

  - IPv4的地址结构形如`255.255.255.255`，一共有4组数（此处是255），每组数能到达的最大值是255，用二进制来表示的话需要用8bit，因此IPv4的地址长度是`4*8=32bit`。
  - IPv6的地址结构形如`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`，一共有8组数，每一组数由4个16进制数组成（此处是ffff），每个16进制数由4位二进制数组成（即一个16进制数f可以表示成1111），所以IPv6的地址长度是`8*4*4=128bit`。

- IPv4、IPv6的presentation形式的大小分析：

  c语言在`<netinet/in.h>`header定义了IPv4和IPv6的presentation表示的长度相关的符号常量，如下：

  ```c
  #define INET_ADDRSTRLEN 16 /* for IPv4 dotted-decimal */
  #define INET6_ADDRSTRLEN 46 /* for IPv6 hex string */
  ```

  但是还是得分析一下这个长度是怎么来的。

  - 对于IPv4最大地址`255.255.255.255`来说，每个10进制数占一个字节，即`3*4=12bytes`，有三个`.`，都占一个字节，即`1*3=3bytes`，再加上c语言中的字符串结束符`\0`，所以一共是`12+3+1=16bytes`。
  - 对于IPv6最大地址`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`来说，一个有8组，每组有4个字符，各占一个字节，再加上7个冒号，冒号是占一个字节，最后再加上`\0`，所以一共是`4*8+7+1=40bytes`
  - 对于IPv6兼容IPv4的地址格式`ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255`来说，一共是`4(即ffff)*6+3(即255)*4+6(即:)+3(即.)+1(即\0)=46bytes`。

  总的来说，对于地址的presentation表示，IPv4地址的最大长度是16bytes，IPv6地址的最大长度是46bytes。

- 为了查询方便，把一些常用的socket地址结构体的定义放在下面：
  - IPv4：

    ```c
    struct in_addr {
    	in_addr_t s_addr; 	/* 32-bit IPv4 address */
    					  	/* network byte ordered */
    };
    
    struct sockaddr_in {
        uint8_t sin_len; 			/* length of structure (16) */
        sa_family_t sin_family; 	/* AF_INET */
        in_port_t sin_port; 		/* 16-bit TCP or UDP port number */
        							/* network byte ordered */
        struct in_addr sin_addr; 	/* 32-bit IPv4 address */
        						 	/* network byte ordered */
        char sin_zero[8]; 			/* unused */
    };
    ```

    IPv4的socket地址结构是固定长度的，一个`sockaddr_in`变量占16bytes，具体组成是：

    - 变量`sin_len`占1bytes，用来保存这个结构的长度；
    - 变量`sin_family`占1bytes；
    - 变量`sin_port`占2bytes；
    - 变量`sin_addr`用来存储IPv4的地址，IPv4的地址是32bits，所以这个变量是4bytes；
    - 变量`sin_zero`是一个char类型的数组，数组大小是8，char类型一般是1bytes，所以这个变量的大小是8bytes。
  
  - IPv6：
  
    ```c
    struct in6_addr {
        uint8_t s6_addr[16]; 	/* 128-bit IPv6 address */
        						/* network byte ordered */
    };
    #define SIN6_LEN /* required for compile-time tests */
    struct sockaddr_in6 {
        uint8_t sin6_len; 			/* length of this struct (28) */
        sa_family_t sin6_family; 	/* AF_INET6 */
        in_port_t sin6_port; 		/* transport layer port# */
        							/* network byte ordered */
        uint32_t sin6_flowinfo; 	/* flow information, undefined */
        struct in6_addr sin6_addr; 	/* IPv6 address */
        							/* network byte ordered */
        uint32_t sin6_scope_id; 	/* set of interfaces for a scope */
    };
    ```
  
    这个IPv6的socket地址结构是定长的，共占28bytes，具体的组成如下所示：

    - 变量`sin6_len`占1bytes；
    - 变量`sin6_family`占1bytes；
    - 变量`sin6_port`占2bytes；
    - 变量`sin6_flowinfo`占4bytes；
    - 变量`sin6_addr`占16bytes；
    - 变量`sin6_scope_id`占4bytes；
  
  - Unix域地址：
  
    ```c
    struct sockaddr_un {
        sa_family_t sun_family; /* AF_LOCAL */
        char sun_path[104]; /* null-terminated pathname */
    };
    ```
  
    存储在 `sun_path` 数组中的路径名必须以空字符结尾。 提供了宏 `SUN_LEN`，它接受一个指向 `sockaddr_un` 结构的指针并返回结构的长度，包括路径名中非空字节的数量。
    未指定的地址由作为路径名的空字符串指示，即 `sun_path[0]` 等于 `0` 的结构。这是 `IPv4` `INADDR_ANY` 常量和 `IPv6` `IN6ADDR_ANY_INIT` 常量的 `Unix` 域等效项。
  
  - 通用socket地址结构：
  
    ```c
    #define	SA	struct sockaddr
    
    struct sockaddr {
        uint8_t sa_len;
        sa_family_t sa_family; 	/* address family: AF_xxx value */
        char sa_data[14]; 		/* protocol-specific address */
    };
    ```
  
  - 新通用socket地址结构：
  
    ```c
    struct sockaddr_storage {
        uint8_t ss_len; 		/* length of this struct (implementation dependent) */
        sa_family_t ss_family; 	/* address family: AF_xxx value */
        /* implementation-dependent elements to provide:
         * a) alignment sufficient to fulfill the alignment requirements of
         * all socket address types that the system supports.
         * b) enough storage to hold any type of socket address that the
         * system supports.
         */
    };
    ```
  
- presentation地址格式与网络二进制地址格式的转化：

  - presentation -> binary value：

    ```c
    // 参数一：地址组
    // 参数二：指向地址字符串的指针
    // 参数三：地址结构的长度
    int inet_pton(int, const char *, void *);
    ```

  - binary value -> presentation：

    ```c
    // 参数一：family地址组
    // 参数二：指向地址结构体的指针
    // 参数三：用来保存presentation表达式的字符串指针
    // 参数四：保存presentation表达式的字符串的大小
    const char	*inet_ntop(int, const void *, char *, size_t);
    ```

- 关于`memcpy`函数实现的说明，参考博客：`https://blog.csdn.net/goodwillyang/article/details/45559925?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control`。

### 4、Elementary TCP Sockets

- 为了方便查询，将TCP服务端和客户端一些函数的基本流程图放下面：

  ![image-20210621095844370](D:\for_wps\WPS Cloud Files\typora_imags\image-20210621095844370.png)

- 关于`connect`函数执行出错时的报错说明：

  - 如果返回的错误信息是`ETIMEDOUT`，即`connect error: Connection timed out`。

    - 如果出现了这个错误，说明服务端存在监听相应端口的进程，但可能这些进程有点儿忙，导致新到的连接不能被及时的处理，导致了超时，**下面是从原理方面来进行说明**：

      服务端程序由函数socket创建的socket，一般需要调用listen将这个socket变成监听socket（下面给出了socket函数和listen函数），才能够接收客户端发送过来的SYN数据报，

      ```c
      #include <sys/socket.h>
      int socket(int family, int type, int protocol);
      int listen(int sockfd, int backlog);
      ```

      首先来分析一下listen函数的两个参数：
      - `int sockfd`：需要传入的是之前由socket函数创建的socket描述符。将服务端的socket从CLOSED状态变成LISTEN状态。

      - `int backlog`：这个参数是用来限定服务端的监听socket某一时刻的最大监听数目（即，同一时刻，最多能够监听多少客户端）。

      第二个参数`backlog`的功能可能不是很好理解，可以看下面的图（Figure 4.7）：

      ![image-20210616201908356](D:\for_wps\WPS Cloud Files\typora_imags\image-20210616201908356.png)

      上图中展示了两个队列（`incomplete connection queue`和`completed connection queue`），这**两个队列的容量之和最大是`backlog`所指定的值**（这个**`backlog`只是一个模糊值**，之后会进行说明）。

      客户端发送一个SYN数据段，这个SYN段到达服务端，会检查`incomplete connection queue`这个队列有没有足够的容量（即有没有超过`backlog`的值），如果有容量，服务端的监听socket会从LISTEN这个状态变成SYN_RCVD状态，之后在`incomplete connection queue`队列中生成一个条目；只要`incomplete connection queue`中存在条目，TCP服务就会从`incomplete connection queue`队列中取出一个条目，尝试进行TCP的三次握手，假设握手成功了，则将`incomplete connection queue`中的条目移动到`completed connection queue`队列中，监听socket从SYN_RCVD状态变成ESTABLISHED状态，等待被服务端的accept函数接收，只有被accept函数接受的条目所对应的客户端才能够和服务端进行通信。

      PS：这里的监听socket的状态在不同的客户端-服务端TCP中可能是不同的，有的处于CLOSED状态，有的处于SYN_RCVD状态，有的处于LISTEN状态，各个客户端-服务端TCP中，同一个socket呈现的不同状态没有任何关系，彼此独立，就拿上面的例子来说，对于处于`incomplete connection queue`条目来说，监听socket处于SYN_RCVD状态，对于`completed connection queue`队列中的条目来说，监听socket处于ESTABLISHED的状态，同一个socket在不同的场景中处于不同的状态，彼此独立。

      如果服务端不是并发的程序，同一时间accept只能处理一个`completed connection queue`队列中的条目，其他的条目只能在队列中等待，直到当前正在通信的客户端与服务端断开连接，accept函数才会从`completed connection queue`队列中选择新的条目对应的客户端，并与之通信。

      上面说参数`backlog`是一个模糊值，是因为不同的操作系统上面`incomplete connection queue`和`completed connection queue`两个队列的最大容量和会根据参数`backlog`的值稍微扩大一点儿，每个操作系统扩大的程度都不相同，如下表所示：

      ![image-20210616205754793](D:\for_wps\WPS Cloud Files\typora_imags\image-20210616205754793.png)
  
      下面就来进行一番测试，测试的环境是`Ubuntu 18.14`，令`backlog = 0`，通过查看上面的表会发现，我的机器上等待连接的实际最大数目是3，也就是说我可以同时启动三个客户端程序，如果这三个程序都没有执行完就启动第四个客户端，第四个程序按道理来说是会出现连接超时的错误的，为了让客户端程序持续与服务端程序连接，可以在accept函数后面加上死循环就可以了，服务端和客户端程序如下图所示：
  
      服务端程序：
  
      ```c
      #include	"unp.h"
      #include	<time.h>
      
      int
      main(int argc, char **argv)
      {
      	int					listenfd, connfd;
      	struct sockaddr_in	servaddr;
      	char				buff[MAXLINE];
      	time_t				ticks;
      
      	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family      = AF_INET;
      	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
      	servaddr.sin_port        = htons(13);	/* daytime server */
      
      	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
      
      	Listen(listenfd, 0);
      
      	for ( ; ; ) {
      		connfd = Accept(listenfd, (SA *) NULL, NULL);
      
              ticks = time(NULL);
              snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
              Write(connfd, buff, strlen(buff));
              // 加一个死循环，不让连接断了
              while(1) {
                  ;
              }
      
      		Close(connfd);
      	}
      }
      ```
  
      客户端程序：
  
      ```c
      #include	"unp.h"
      
      int
      main(int argc, char **argv)
      {
      	int					sockfd, n;
      	char				recvline[MAXLINE + 1];
      	struct sockaddr_in	servaddr;
      
      	if (argc != 2)
      		err_quit("usage: a.out <IPaddress>");
      
      	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
      		err_sys("socket error");
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family = AF_INET;
      	servaddr.sin_port   = htons(13);	/* daytime server */
      	if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
      		err_quit("inet_pton error for %s", argv[1]);
      
      	if (connect(sockfd, (SA *) &servaddr, sizeof(servaddr)) < 0)
      		err_sys("connect error");
      
      	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) {
      		recvline[n] = 0;	/* null terminate */
      		if (fputs(recvline, stdout) == EOF)
      			err_sys("fputs error");
      	}
      	if (n < 0)
      		err_sys("read error");
      
      	exit(0);
      }
      ```

      下面是进行的测试。

      ![](D:\for_wps\WPS Cloud Files\typora_imags\test_socket_timedout.gif)

    - 另一种情况是，客户端访问的IP是`ping`不通的，个人觉得应该反馈的错误信息是`EHOSTUNREACH` or `ENETUNREACH`，即`connect error: No route to host`会比较好。

  - 如果返回的错误信息是`ECONNREFUSED`，即`connect error: Connection refused`。

    如果出现了这个错误，说明访问的IP是存在的，且存在一条链路可以到达这个IP，即通过命令`ping`进行测试是能够成功的，但是这个主机上不存在监听相应端口的进程，所以连接被拒绝了，就会出现这个错误。

    在本地不运行服务端程序就运行客户端程序，使用本地的IP访问本地主机，这种场景下`connect`函数就会报这个错误，因为不存在相关的监听进程。
  
  - 如果返回的错误信息是`EHOSTUNREACH` or `ENETUNREACH`，即`connect error: No route to host`。

    出现这个错误说明，网络不可达，不存在到达需要访问主机IP的通路。使用`ping`命令会显示以下错误：
  
    ```shell
    From 192.168.182.135 icmp_seq=1 Destination Host Unreachable
    ```

- 关于服务端listen函数，如果客户端连接数增加，在不改变源码，不重新编译的情况下，只通过重启服务来改变listen函数的第二个参数backlog，从而扩大客户端连接的数目的相关说明。

  首先需要明白一点，服务端程序的生命周期中，只会存在一个监听socket，即只会调用一次listen函数，只对客户端连接数进行一次指定，编译运行后就不能再更改了，如果需要修改，一般的方法是打开源码，直接修改listen函数中第二个参数backlog的值，这样往往需要重新将代码进行编译，其实还有可以不进行编译，直接重启服务的方法，如下：

  - 在开启服务端程序的时候，通过命令行参数进行指定，根据命令行参数的值，传入到listen函数进行客户端连接数目的扩充。

  - 通过指定某个环境变量的值，在重启服务端程序的时候，获取相应的环境变量，进而传入到listen函数进行客户端连接数目的扩充。

    可以对listen函数进行一定的包装，变成如下的形式：

    ```c
    void Listen(int fd, int backlog)
    {
        char *ptr;
        /* can override 2nd argument with environment variable */
        if ( (ptr = getenv("LISTENQ")) != NULL)
        	backlog = atoi(ptr);
        if (listen(fd, backlog) < 0)
        	err_sys("listen error");
    }
    ```

    上面的函数通过getenv函数来获得系统中的环境变量的值，返回的是一个字符串，此函数的声明如下：

    ```c
    #include <stdlib.h>
    char *getenv(const char *name);
    ```

- 关于使用fork函数实现一个简单的并发服务端的细节说明：

  ```c
  pid_t pid;
  int listenfd, connfd;
  listenfd = Socket( ... );
  /* fill in sockaddr_in{} with server’s well-known port */
  Bind(listenfd, ... );
  Listen(listenfd, LISTENQ);
  for ( ; ; ) {
      connfd = Accept(listenfd, ... ); /* probably blocks */
      if ( (pid = Fork()) == 0) {
          Close(listenfd);/* child closes listening socket */
          doit(connfd); 	/* process the request */
          Close(connfd); 	/* done with this client */
          exit(0); 		/* child terminates */
      }
      Close(connfd); /* parent closes connected socket */
  }
  ```

  socket和文件类似，一个socket对应一个描述符，每个描述符都有一个描述符引用计数器（Descriptor Reference Counts），用来记录描述符对应的socket被引用的次数，当计数器的值为0的时候，说明某个socket没有被引用，则该socket就会被内核所删除，有了这个知识点之后，来分析一下上面的程序：

  当父进程执行到语句`connfd = Accept(listenfd, ... );`，此时会生成一个`connect socket`，之后会进行if语句中的条件判断，由于fork函数向子进程返回0，向父进程返回子进程的pid（非0），所以父进程会直接执行语句`Close(connfd);`，子进程则会执行if内的语句。

  在fork出子进程的时候，内核会将父进程中打开的描述符复制一份到子进程中，因此，此时监听socket和连接socket的描述符引用计数器都为2。

  按照程序处理的需求来说，子进程只需要通过连接socket与客户端进行交互而不需要进行监听，因此在子进程中将子进程的监听socket描述符关闭合情合理；父进程只需要将客户端的请求交给子进程处理，因此只需要监听就行，因此在父进程的代码中将父进程的连接socket描述符关闭也合情合理，所以子进程的代码中会有`Close(listenfd);`语句，父进程的代码中会有`Close(connfd);`语句，执行了这两个语句之后，监听socket和连接socket的计数器从2变成了1，由于还未到0，所以并不会被内核删除，依然可以正常使用。

  程序的详细执行过程如下：

  - 首先由客户段调用`connect`函数向服务端发起连接，如下图：

    ![image-20210617213219674](D:\for_wps\WPS Cloud Files\typora_imags\image-20210617213219674.png)

  - 服务端调用`accept`函数创建一个conned描述符（这个描述符指向一个连接socket，引用计数器此时为1）与客户端建立连接，如下图：

    ![image-20210617213542249](D:\for_wps\WPS Cloud Files\typora_imags\image-20210617213542249.png)

  - 服务端fork一个子进程，来处理与刚才建立连接的客户端请求，fork会将父进程中打开的描述符复制一份到子进程中，此时监听socket的描述符引用计数器（Descriptor Reference Counts）和连接socket的描述符引用计数器的值都为2，如下图：

    ![image-20210617213835986](D:\for_wps\WPS Cloud Files\typora_imags\image-20210617213835986.png)

  - 父进程删除连接socket的描述符，子进程删除监听socket的描述符，此时监听socket的描述符引用计数器（Descriptor Reference Counts）和连接socket的描述符引用计数器的值都从2变成了1，如下图：

    ![image-20210617214046402](D:\for_wps\WPS Cloud Files\typora_imags\image-20210617214046402.png)

    之后子进程处理和客户端有关的请求，父进程负责监听下一个客户端的连接。

- 下面是对一些网络编程中常用的函数进行测试：

  - `inet_aton`函数：

    函数原型如下：

    ```c
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    
    int inet_aton(const char *cp, struct in_addr *inp);
    ```

    函数功能：将一个主机字节序的ASCII表示形式（即字符串表示形式）转换成网络字节序；函数名称中的`a`表示`ASCII`，`n`表示`network`的意思；如果函数执行成功则返回1，如果执行失败则返回0。**用于IPv4的地址格式**。

    测试代码如下：

    ```c
    #include <stdio.h>
    #include <limits.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    
    void test_inet_aton(char *host_byte_order) {
        printf("host_byte_order = %s\n", host_byte_order);
        struct in_addr IPv4addr_foraton;
        int result_foraton = inet_aton(host_byte_order, &IPv4addr_foraton);
        if (result_foraton) {
            printf("inet_aton success\n");
            printf("network bytes order = %u\n", IPv4addr_foraton.s_addr);
        } else {
            printf("host_byte_order error");
        }
        printf("\n");
    }
    
    int main() {
        test_inet_aton("255.255.255.255");
        test_inet_aton("1255.255.255.255");
        return 0;
    }
    
    /* output:
    host_byte_order = 255.255.255.255
    inet_aton success
    network bytes order = 4294967295
    
    host_byte_order = 1255.255.255.255
    host_byte_order error
    
    */
    ```

    从上面的结果可以看出，非法输入`1255.255.255.255`被检查了出来。

  - `htonl`函数：

    函数原型如下所示：

    ```c
    #include <netinet/in.h>
    
    uint32_t htonl(uint32_t hostlong);
    ```

    函数功能：将一个主机字节序（无符号32位int类型）变成一个网络字节序（无符号32位int类型）。**这个函数应该尽可能少用**，因为不会进行错误信息的提示，如果输入了一个long类型的数据，会自动将高位截取，程序依然可以正常执行，所以还是使用`inet_aton`函数会比较好。**用于IPv4的地址格式**。

    关于此函数的测试如下：

    ```c
    #include <stdio.h>
    #include <limits.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    
    void test_order_convert(unsigned int host_byte_order) {
        printf("host_byte_order_dec = %u\n", host_byte_order);
        printf("host_byte_order_hex = 0x%x\n", host_byte_order);
        struct in_addr IPv4addr;
        IPv4addr.s_addr = htonl(host_byte_order);
        printf("network_byte_order = %u\n", IPv4addr.s_addr);
        char str[INET_ADDRSTRLEN];
        const char *presentation = inet_ntop(AF_INET, &IPv4addr, str, sizeof(str));
        printf("host_byte_order_presentation = %s\n", presentation);
        printf("\n");
    
    }
    
    int main() {
        test_order_convert(0x7fffffff);
        test_order_convert(0xffffffff);
        return 0;
    }
    
    /* 输出如下：
    host_byte_order_dec = 2147483647
    host_byte_order_hex = 0x7fffffff
    network_byte_order = 4294967167
    host_byte_order_presentation = 127.255.255.255
    
    host_byte_order_dec = 4294967295
    host_byte_order_hex = 0xffffffff
    network_byte_order = 4294967295
    host_byte_order_presentation = 255.255.255.255
    
    
    */
    ```

    上面代码中主机字节序（`host_byte_order_dec`和`host_byte_order_hex`）和主机字节序的字符串表示（`host_byte_order_presentation`）是存在关联的，就拿主机字节序的16进制数`0x7fffffff`来说，将其转换成二进制数为`0111 1111,1111 1111,1111 1111,1111,1111`，而对于其字符串表示，`.`分割的每个数都是一个小于等于255的数，因此主机字节序的字符串表示会将32位的主机字节序每8位用`.`进行分隔，即`0111 1111.1111 1111.1111 1111.1111,1111`，转换成十进制数就是`127.255.255.255`了。

    至于主机序转换成网络序的原理就是：拿地址`224.0.0.1`来进行说明，先把这个地址以字节为单位写成这样`e0 00 00 01`，这就是主机字节序，如果我的电脑是小端存储，那么其对应的网络字节序（网络字节序是大端存储）就是`01 00 00 e0`，相当于是将主机字节序，按字节为单位逆序了。

  - `htons`函数：

    函数原型如下所示：

    ```c
    #include <arpa/inet.h>
    
    uint16_t htons(uint16_t hostshort);
    ```

    函数功能：传入的参数是一个16位的`short int`类型，功能同`htonl`函数一样，可以将主机字节序转变成网络字节序，一般`htonl`函数用于将IPv4地址转成网络字节序，`htons`用于将端口号转成字节序。

  - `ntohl`函数：

    函数原型如下：

    ```c
    #include <arpa/inet.h>
    
    uint32_t ntohl(uint32_t netlong);
    ```

    函数功能：是`htonl`函数的逆过程，可以将网络字节序转成主机字节序。

  - `ntohs`函数：

    函数原型如下：

    ```c
    #include <arpa/inet.h>
    
    uint16_t ntohs(uint16_t netshort);
    ```

    函数功能：是`htons`函数的逆过程，可以将网络字节序转成主机字节序。

  - `getsockname`函数：

    函数原型：

    ```c
    #include <sys/socket.h>
    
    int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    ```

    函数功能：获得某个socket的主机IP地址和PORT。第一个参数**一般是connect sockfd**，第二个参数是IP地址的引用，第三个参数是第二个参数长度的引用。

    下面是对这个函数的一些测试：

    - 将这个函数应用到客户端：

      服务端程序如下：

      ```c
      #include	"unp.h"
      #include	<time.h>
      
      int
      main(int argc, char **argv)
      {
      	int					listenfd, connfd;
      	struct sockaddr_in	servaddr;
      	char				buff[MAXLINE];
      	time_t				ticks;
      
      	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family      = AF_INET;
      	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
      	servaddr.sin_port        = htons(13);	/* daytime server */
      
      	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
      
      	Listen(listenfd, LISTENQ);
      
      	for ( ; ; ) {
      		connfd = Accept(listenfd, (SA *) NULL, NULL);
      
              ticks = time(NULL);
              snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
              Write(connfd, buff, strlen(buff));
      
      		Close(connfd);
      	}
      }
      ```

      上面的服务端程序应该要率先执行。

      客户端程序如下：

      ```c
      #include	"unp.h"
      
      void getsockname_info(int sockfd) {
          struct sockaddr_storage ss;
          socklen_t len;
          len = sizeof(ss);
          if (getsockname(sockfd, (SA *) &ss, &len) < 0) {
              err_sys("getsockname function error");
          }
          struct sockaddr_in *IPv4sock = (struct sockaddr_in *)&ss;
          printf("IPv4 family: %d\n", IPv4sock->sin_family);
          printf("IPv4 port: %d\n", ntohs(IPv4sock->sin_port));
          printf("IPv4 addr: %s\n", inet_ntoa(IPv4sock->sin_addr));
          printf("IPv4 socket: %s\n", sock_ntop((struct sockaddr *)&ss, 0));
      }
      
      int
      main(int argc, char **argv)
      {
      	int					sockfd, n;
      	char				recvline[MAXLINE + 1];
      	struct sockaddr_in	servaddr;
      
      	if (argc != 2)
      		err_quit("usage: a.out <IPaddress>");
      
      	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
      		err_sys("socket error");
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family = AF_INET;
      	servaddr.sin_port   = htons(13);	/* daytime server */
      	if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
      		err_quit("inet_pton error for %s", argv[1]);
      
      	if (connect(sockfd, (SA *) &servaddr, sizeof(servaddr)) < 0)
      		err_sys("connect error");
      
          getsockname_info(sockfd);
      
      	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) {
      		recvline[n] = 0;	/* null terminate */
      		if (fputs(recvline, stdout) == EOF)
      			err_sys("fputs error");
      	}
      	if (n < 0)
      		err_sys("read error");
      
      	exit(0);
      }
      
      /* output
      IPv4 family: 2
      IPv4 port: 41938
      IPv4 addr: 192.168.182.138
      IPv4 socket: 192.168.182.138:41938
      Sat Jun 19 19:34:24 2021
      */
      ```

      上面的代码中的`sock_pton`函数并不是c库函数，而实《UNIX网络编程》作者自己写的函数，下面会给出介绍，其功能就是将IP地址和端口拼接起来。

      从上面的输出中可以看出与服务端连接的IP地址是`192.168.182.138`，系统分配给客户端的端口是`41938`。

    - 将这个函数应用于服务端：

      服务端程序如下：

      ```c
      #include	"unp.h"
      #include	<time.h>
      void getsockname_info(int sockfd) {
          struct sockaddr_storage ss;
          socklen_t len;
          len = sizeof(ss);
          if (getsockname(sockfd, (SA *) &ss, &len) < 0) {
              err_sys("getsockname function error");
          }
          struct sockaddr_in *IPv4sock = (struct sockaddr_in *)&ss;
          printf("IPv4 family: %d\n", IPv4sock->sin_family);
          printf("IPv4 port: %d\n", ntohs(IPv4sock->sin_port));
          printf("IPv4 addr: %s\n", inet_ntoa(IPv4sock->sin_addr));
          printf("IPv4 socket: %s\n", sock_ntop((struct sockaddr *)&ss, 0));
      }
      int
      main(int argc, char **argv)
      {
      	int					listenfd, connfd;
      	struct sockaddr_in	servaddr;
      	char				buff[MAXLINE];
      	time_t				ticks;
      
      	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family      = AF_INET;
      	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
      	servaddr.sin_port        = htons(13);	/* daytime server */
      
      	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
      
          printf("listenfd: \n");
          getsockname_info(listenfd);
          printf("wait for client connecting\n\n");
      
      	Listen(listenfd, LISTENQ);
      
      	for ( ; ; ) {
      		connfd = Accept(listenfd, (SA *) NULL, NULL);
              printf("client is comming\n");
              printf("connfd: \n");
              getsockname_info(connfd);
      
              ticks = time(NULL);
              snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
              Write(connfd, buff, strlen(buff));
      
      		Close(connfd);
      	}
      }
      
      /* output
      listenfd: 
      IPv4 family: 2
      IPv4 port: 13
      IPv4 addr: 0.0.0.0
      IPv4 socket: 0.0.0.0:13
      wait for client connecting
      
      client is comming
      connfd: 
      IPv4 family: 2
      IPv4 port: 13
      IPv4 addr: 192.168.182.138
      IPv4 socket: 192.168.182.138:13
      
      */
      ```

      服务端的IP地址一开始被赋值为`htonl(INADDR_ANY)`，即`0.0.0.0`，相当于通配符（感觉0就表示通配符），之后使用Bind绑定这个地址时，系统会根据客户端真实访问的主机IP建立connfd。这也就是为什么使用`getsockname(listenfd)`打印服务端主机是输出`0.0.0.0`，而使用`getsockname(connfd)`的时候输出的是`192.168.182.138`，因为客户端访问的服务端的地址就是`192.168.182.138`。

      客户端程序如下：

      ```c
      #include	"unp.h"
      
      int
      main(int argc, char **argv)
      {
      	int					sockfd, n;
      	char				recvline[MAXLINE + 1];
      	struct sockaddr_in	servaddr;
      
      	if (argc != 2)
      		err_quit("usage: a.out <IPaddress>");
      
      	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
      		err_sys("socket error");
      
      	bzero(&servaddr, sizeof(servaddr));
      	servaddr.sin_family = AF_INET;
      	servaddr.sin_port   = htons(13);	/* daytime server */
      	if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
      		err_quit("inet_pton error for %s", argv[1]);
      
      	if (connect(sockfd, (SA *) &servaddr, sizeof(servaddr)) < 0)
      		err_sys("connect error");
      
      	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) {
      		recvline[n] = 0;	/* null terminate */
      		if (fputs(recvline, stdout) == EOF)
      			err_sys("fputs error");
      	}
      	if (n < 0)
      		err_sys("read error");
      
      	exit(0);
      }
      ```

  - `sock_ntop`函数：

    这个函数不是c库函数，而是作者实现的一个函数，函数实现如下：

    ```c
    char *
    sock_ntop(const struct sockaddr *sa, socklen_t salen)
    {
        char		portstr[8];
        static char str[128];		/* Unix domain is largest */
    
    	switch (sa->sa_family) {
    	case AF_INET: {
    		struct sockaddr_in	*sin = (struct sockaddr_in *) sa;
    
    		if (inet_ntop(AF_INET, &sin->sin_addr, str, sizeof(str)) == NULL)
    			return(NULL);
    		if (ntohs(sin->sin_port) != 0) {
    			snprintf(portstr, sizeof(portstr), ":%d", ntohs(sin->sin_port));
    			strcat(str, portstr);
    		}
    		return(str);
    	}
    /* end sock_ntop */
    
    #ifdef	IPV6
    	case AF_INET6: {
    		struct sockaddr_in6	*sin6 = (struct sockaddr_in6 *) sa;
    
    		str[0] = '[';
    		if (inet_ntop(AF_INET6, &sin6->sin6_addr, str + 1, sizeof(str) - 1) == NULL)
    			return(NULL);
    		if (ntohs(sin6->sin6_port) != 0) {
    			snprintf(portstr, sizeof(portstr), "]:%d", ntohs(sin6->sin6_port));
    			strcat(str, portstr);
    			return(str);
    		}
    		return (str + 1);
    	}
    #endif
    
    #ifdef	AF_UNIX
    	case AF_UNIX: {
    		struct sockaddr_un	*unp = (struct sockaddr_un *) sa;
    
    			/* OK to have no pathname bound to the socket: happens on
    			   every connect() unless client calls bind() first. */
    		if (unp->sun_path[0] == 0)
    			strcpy(str, "(no pathname bound)");
    		else
    			snprintf(str, sizeof(str), "%s", unp->sun_path);
    		return(str);
    	}
    #endif
    
    #ifdef	HAVE_SOCKADDR_DL_STRUCT
    	case AF_LINK: {
    		struct sockaddr_dl	*sdl = (struct sockaddr_dl *) sa;
    
    		if (sdl->sdl_nlen > 0)
    			snprintf(str, sizeof(str), "%*s (index %d)",
    					 sdl->sdl_nlen, &sdl->sdl_data[0], sdl->sdl_index);
    		else
    			snprintf(str, sizeof(str), "AF_LINK, index=%d", sdl->sdl_index);
    		return(str);
    	}
    #endif
    	default:
    		snprintf(str, sizeof(str), "sock_ntop: unknown AF_xxx: %d, len %d",
    				 sa->sa_family, salen);
    		return(str);
    	}
        return (NULL);
    }
    ```

    函数功能：可以将各个地址协议变成一种更可读的形式，比如，对于IPv4的地址，该函数就可以将地址的presentation表示和端口号进行拼接，并将拼接好的字符串返回，这样就更可读。第一个参数是通用地址结构体的引用，第二个参数是它的大小，最后的返回值是一个字符串指针，如果执行失败的话，返回值是一个NULL。注意：`snprintf`函数会在给一个字符串数组赋值之后，在末尾自动添加一个`\0`，作为结束。

  - `inet_pton`函数：

    函数原型如下：

    ```c
    #include <arpa/inet.h>
    
    int inet_pton(int af, const char *src, void *dst);
    ```

    函数功能：将地址的字符串形式转成网络字节序。函数执行成功将返回1，执行失败将返回0。第一个参数是地址族，用来指定地址是IPv4地址还是IPv6地址，第二个参数是地址的字符串形式，注意如果地址是IPv4，用`.`分割的数字是十进制数，如果是八进制或者十六进制数的形式，执行会失败。第三个参数是地址结构体，**转换之后的网络字节序会保存在第三个参数中**。

    下面是对`inet_pton`函数的测试。

    ```c
    #include <arpa/inet.h>
    #include <stdio.h>
    #include <netinet/in.h>
    
    int main() {
        char *host_ip = "224.0.0.21";
        struct in_addr IPv4addr;
        int result = inet_pton(AF_INET, host_ip, &IPv4addr);
        if (result) {
            printf("inet_pton success\n");
            printf("address presentation: %s\n", host_ip);
            printf("network byte order: %x\n", IPv4addr.s_addr);
            printf("host byte order: %x\n", ntohl(IPv4addr.s_addr));
        } else {
            printf("inet_pton error\n");
        }
        return 0;
    }
    
    /* output
    inet_pton success
    address presentation: 224.0.0.21
    network byte order: 150000e0
    host byte order: e0000015
    */
    ```

  - `inet_ntop`函数：

    函数原型如下：

    ```c
    #include <arpa/inet.h>
    
    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
    ```

    函数的功能：将一个网络字节序转成地址的字符串形式。第一个参数是指明地址族，第二个参数是地址结构体的引用，第三个参数是最后保存地址字符串形式的字符串数组引用，第四个参数是地址的字符串形式的长度，一般第四个参数是有下面两个定义来指定：

    ```c
    #define INET_ADDRSTRLEN 16 /* for IPv4 dotted-decimal */
    #define INET6_ADDRSTRLEN 46 /* for IPv6 hex string */
    ```

    这个函数如果执行成功，最后的返回值是指向地址字符串的指针，一般是第三个参数的指针，如果执行失败了返回值是一个NULL。

    下面是对`inet_ntop`函数的测试：

    ```c
    #include <arpa/inet.h>
    #include <stdio.h>
    #include <netinet/in.h>
    
    int main() {
        char *host_ip = "224.0.0.21";
        struct in_addr IPv4addr;
        int result = inet_pton(AF_INET, host_ip, &IPv4addr);
        if (result) {
            printf("inet_pton success\n");
            printf("address presentation: %s\n", host_ip);
            printf("network byte order: %x\n", IPv4addr.s_addr);
        } else {
            printf("inet_pton error\n");
        }
        printf("after exec inet_ntop\n");
        char buf[INET_ADDRSTRLEN];
        printf("address presentation: %s\n", inet_ntop(AF_INET, &IPv4addr, buf, INET_ADDRSTRLEN));
        return 0;
    }
    
    /*
    inet_pton success
    address presentation: 224.0.0.21
    network byte order: 150000e0
    after exec inet_ntop
    address presentation: 224.0.0.21
    
    */
    ```

    上面的代码传入的地址是`224.0.0.21`，之后先变成网络字节序，再调用`inet_ntop`方法，将网络字节序变回地址的字符串表示。

  - `bind`函数：

    函数原型如下：
    
    ```c
    #include <sys/socket.h>
    
    int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
    ```
    
    函数功能：第一个参数是一个socket描述符，第二个参数传入的是一个通用地址结构体，第三个参数是通用地址结构体的大小；如果函数执行成功将返回0，如果执行失败了将返回-1。
    
    将某个IP地址、端口号和socket描述符进行绑定。一般用于服务端的程序，服务端程序只能接收发送给他的socket描述符绑定的IP和端口的数据。
    
    而客户端一般是不需要使用bind函数将其socket描述符与需要发送数据的地址和端口进行绑定，内核会在客户端和服务端的connect socket进行连接的时候根据路由进行选择。
    
    如果服务端没有将服务端的socket与特定的IP地址绑定，那么内核会将客户端发送数据指定的目标地址作为服务端的接收数据的IP地址。
    
    下面是为了方便起见放出的一个`bind`函数在地址和端口取不同的值的时候最后绑定的结果：
    
    ![image-20210618103050470](D:\for_wps\WPS Cloud Files\typora_imags\image-20210618103050470.png)
    
    - IP地址采用通配符，port取0：内核会自动分配一个IP地址和port，如果是服务端，内核会根据客户端发送数据指定的目标IP来给服务端选择IP。
    - IP地址通配，port非零：内核会自动分配一个IP地址，不过port是采用的用户指定的port。
    - IP地址确定，port取0：进程采用指定的IP地址，port由内核进行自动分配。
    - IP地址确定，port非零：进程采用指定的IP地址和port。
    
    对于IPv4地址结构，如果要为其指定通配的IP地址，可以通过如下的代码进行指定：
    
    ```c
    #include <netinet/in.h>
    
    struct sockaddr_in servaddr;
    
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* wildcard */
    ```
    
    其中的`INADDR_ANY`的值为0。
    
    对于IPv6地址结构，如果要为其指定通配的IP地址，可以通过如下的代码进行指定：
    
    ```c
    #include <netinet/in.h>
    
    struct sockaddr_in6 serv;
    
    serv.sin6_addr = in6addr_any; /* wildcard */
    ```
    
  - `fork`函数：

    函数原型如下所示：

    ```c
    #include <sys/types.h>
    #include <unistd.h>
    
    pid_t fork(void);
    ```

    函数功能：通过复制调用进程来**创建一个新进程**，该新进程称为子进程，子进程是父进程的**副本**。不过，子进程和父进程的进程ID是不一样的。如果函数执行成功将返回一个大于等于0的值（在子进程中返回0，在父进程中返回子进程的`pid`），如果执行失败了将在父进程中返回-1，然后设置`errno`变量的值。

    子进程的执行进度如何？

    子进程的执行进度和父进程的执行进度是相同的，也就是说，子进程会等**`fork`函数返回之后执行剩下的代码段**。

    如果子进程结束，父进程还在运行但是却没有将子进程回收，此时子进程没有任何作用但仍然占用资源，因此会变成僵尸进程。如果子进程结束之前父进程先结束了，那么子进程结束后其父进程将变成1号进程，最终由1号进程进行回收。下面是相关的测试：

    ```c
    #include <stdio.h>
    #include <sys/wait.h>
    #include <sys/types.h>
    #include <unistd.h>
    
    int main() {
        pid_t pid = fork();
        if(pid > 0) {
            sleep(10);
            wait(NULL); // 先睡10秒之后再回收子进程
            printf("collect child\n");
            sleep(5); // 回收完子进程后再睡5秒，父进程结束
            printf("father end\n");
        } else if(pid == 0) {
            printf("child end\n");
        }
        return 0;
    }
    ```

    下面是关于上面代码的演示：

    ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_fork.gif)

    **父进程中一定要调用`wait`函数回收子进程。**

  - 关于`exec`函数族的说明：

    函数原型如下：

    ```c
    #include <unistd.h>
    
    extern char **environ;
    
    int execl(const char *path, const char *arg, ... /* (char  *) NULL */);
    int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
    int execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */);
    int execv(const char *path, char *const argv[]);
    int execvp(const char *file, char *const argv[]);
    int execvpe(const char *file, char *const argv[], char *const envp[]);
    ```

    上面的函数都差不多，就拿函数`execlp`来举例说明功能：第一个参数是可执行文件的路径，第二个参数是可执行文件的参数列表，这个参数列表中的第一个元素为可执行文件的名称，最后一个元素是`NULL`。

    总结：

    - 子进程进场调用上面的`exec`函数来执行另一个程序。

    - 当进程调用一种`exec`函数，该进程的用户空间代码和数据**完全被新程序替换**（可以理解为内存空间被替换），从新程序的开始执行。

    - 调用`exec`并**不创建新进程**，所以**调用`exec`前后进程ID并不会改变**。

    - `exec`函数只有在发生错误的时候才会返回，返回值是-1。下面是针对这一点进行的测试。

      ```c
      #include <stdio.h>
      #include <sys/wait.h>
      #include <sys/types.h>
      #include <unistd.h>
      
      int main() {
          pid_t pid = fork();
          if(pid == 0) {
              // 在子进程中执行touch命令在当前目录创建一个新文件aaa.txt
              execlp("/bin/touch", "touch", "aaa.txt", NULL);
              printf("execlp run error\n");
          } else if (pid > 0) {
              printf("father wait for child\n");
              wait(NULL);
          }
          return 0;
      }
      ```

      下面是对上面代码的演示

      ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_exec_fuc.gif)

- 关于小端存储和大端存储的说明：

  数据的存储有两种方式，一种是小端存储，另一种是大端存储，如下图所示：

  ![image-20210619093703339](D:\for_wps\WPS Cloud Files\typora_imags\image-20210619093703339.png)

  根据上图的来举个例子，假设16位数值用16进制数来表示位`0x0102`，01对应的是MSB（即最高有效位），02对应的是LSB（即最低有效位），**对于小端存储来说，数值的存储方式是较低的地址存放较低的有效位，较高地址存放较高有效位**，因此对于16进制数`0x0102`来说，较低有效位的数字02存放在较低的地址A，较高有效位的数字01存放在较高的地址A + 1；而大端储存方式则恰恰相反，**数值的存储方式是较低的地址存放较高的有效位，较高地址存放较低有效位**，因此对于16进制数`0x0102`来说，较高有效位的数字01存放在较低的地址A，较低有效位的数字02存放在较高的地址A + 1。

  假设`int tmp = 0x01020304`，计算机系统1byte是8bit，`tmp`变量分别采用小端和大端存储的内存分布如下：

  | 地址            | 1                | 2    | 3    | 4                |
  | --------------- | ---------------- | ---- | ---- | ---------------- |
  | tmp采用小端存储 | 04（最低有效位） | 03   | 02   | 01（最高有效位） |
  | tmp采用大端存储 | 01（最高有效位） | 02   | 03   | 04（最低有效位） |

  如果要根据大小端存储从内存中解读出数值tmp的字面量表示可以遵循规律（只能应用于数值类型，比如int，如果是数值，可能就不一样了）：如果地址从左到右依次增大，对于小端存储的数据来说，可以从右往左依次取出每个内存中的数据进行拼接，比如上表，从右往左依次是01、02、03、04；对于大端存储的数据来说，可以从左往右依次取出每个内存中的数据进行拼接，比如上表，从左往右依次是01、02、03、04。

- 如何判断头文件`<netinet/in.h>`中定义的以`INADDR_`为前缀的常量是主机字节序还是网络字节序：

  系统中存储数据的方式有的是小端存储，有的是大端存储（关于小端存储和大端存储看上面的总结），而**网咯字节序的存储方式是大端存储**，为了实现不同存储方式的兼容，于是就有了`htonl`、`htons`、`ntohl`、`ntohs`这些函数来实现这种转换，如果本机系统上是小端存储，那么这些函数就会有具体的实现，如果本机系统是大端存储，那么这四个函数将会被定义成空宏。

  可以通过下面的程序来查看自己系统上的存储方式是小端存储还是大端存储：

  ```c
  #include <stdio.h>
  
  int main(int argc, char **argv)
  {
  	union {
  	  short  s;
        char   c[sizeof(short)];
      } un;
  
  	un.s = 0x0102;
  	if (sizeof(short) == 2) {
  		if (un.c[0] == 1 && un.c[1] == 2)
  			printf("big-endian\n");
  		else if (un.c[0] == 2 && un.c[1] == 1)
  			printf("little-endian\n");
  		else
  			printf("unknown\n");
  	} else
  		printf("sizeof(short) = %lu\n", sizeof(short));
  
      return 0;
  }
  
  /* 我的机器上是小端存储
  little-endian
  */
  ```

  从上面代码的输出来看，**我的机器上的数值存储方式是小端存储**。

  有了上面的知识，就来看一下头文件`<netinet/in.h>`中的关于常量`INADDR_ALLHOSTS_GROUP`的说明：

  ```c
  #define INADDR_ALLHOSTS_GROUP	((in_addr_t) 0xe0000001) /* 224.0.0.1 */
  ```

  从上面的代码中可以知道，常量`INADDR_ALLHOSTS_GROUP`表示的地址是`224.0.0.1`，其对应的数值位`0xe0000001`，如果系统是大端存储，头文件`<netinet/in.h>`中的关于常量`INADDR_ALLHOSTS_GROUP`的定义应该是`#define INADDR_ALLHOSTS_GROUP	((in_addr_t) 0x010000e0)`，但我的系统上却是上面的代码，上面的定义采用的是小端存储的方式，根据之前的说明，网络字节序一定是大端存储，所以这种采用小端存储的字节序，一定是主机字节序。

  如果计算机系统是小端存储可以执行下面的程序来判断一个序列是主机字节序还是网络网络字节序：
  
  ```c
  #include <stdio.h>
  #include <limits.h>
  #include <arpa/inet.h>
  #include <netinet/in.h>
  
  void test_inet_aton(char *host_address) {
      printf("host address = %s\n", host_address);
      struct in_addr IPv4addr_foraton;
      int result_foraton = inet_aton(host_address, &IPv4addr_foraton);
      if (result_foraton) {
          printf("inet_aton success\n");
          printf("network bytes order = %x\n", IPv4addr_foraton.s_addr);
          printf("host bytes order = %x\n", ntohl(IPv4addr_foraton.s_addr));
      } else {
          printf("host address error");
      }
      printf("\n");
  }
  
  int main() {
      test_inet_aton("224.0.0.21");
      return 0;
  }
  
  /* output
  host address = 224.0.0.21
  inet_aton success
  network bytes order = 150000e0
  host bytes order = e0000015
  
  */
  ```

- 关于TCP发送RST（reset）分节的三种情况的总结：

  - 当SYN到达某端口，但此端口上没有正在监听的服务器进程，此时服务端会发送一个RST给客户端。

  - TCP想取消一个已有的连接，目前遇到了两种这样的情况：

    - 客户端在服务端的accept函数返回之前断开了连接，会向服务端发送发送一个RST（书中的5.11有说明，下面是书中的图）。

      ![image-20210702165534818](D:\for_wps\WPS Cloud Files\typora_imags\image-20210702165534818.png)

    - 并发服务端程序中处理客户端请求的子进程被kill了，这样服务端会向客户端发送一个FIN信号，告诉客户端服务端不再发送数据（但可以接收数据），当客户端向服务端的缓冲区写数据的时候，服务端会向客户端发送一个RST（数中5.12会讲）。

  - TCP接收到了一个根本不存在的连接上的分节（这种情况还没遇到过）。

### 5、TCP Client/Server Example

- 为了方便起见将`echo client/server`的执行流程图放在下面（Figure 5.1）：

  ![image-20210701093107053](D:\for_wps\WPS Cloud Files\typora_imags\image-20210701093107053.png)

- 关于函数指针的说明

  函数指针顾名思义就是指向函数的指针，指向函数地址，是一个变量。函数指针的定义可以是如下：

  ```c
  int (*pfuc)(double, char *);
  ```

  上面的语句的意思是，定义了一个函数指针变量，变量名是`pfuc`，这个函数可以指向一个满足一定条件的函数，满足的条件是：此函数的返回值是一个`int`类型，并且有两个参数，一个是`double`，一个是`char *`类型。

  下面是关于函数指针的简单测试：

  ```c
  #include <stdio.h>
  
  int (*pfunc)(int, int);
  
  int add(int, int);
  int multi(int, int);
  
  int main() {
      pfunc = add;
      printf("when pfunc is add, func return is %d\n", (*pfunc)(1, 2));
      pfunc = multi;
      printf("when pfunc is multi, func return is %d\n", (*pfunc)(1, 2));
      return 0;
  }
  
  int add(int a, int b) {
      return a + b;
  }
  
  int multi(int a, int b) {
      return a * b;
  }
  
  /* output
  when pfunc is add, func return is 3
  when pfunc is multi, func return is 2
  */
  ```

  上面的代码能够直接通过语句`pfunc = multi;`让函数指针指向`multi`函数的原因在于，函数名本身就代表地址，因此可以直接给函数指针赋值。

  **PS：**如果将函数指针外面的`()`去掉的话，函数指针就变成了返回一个指针类型的函数了，因为`()`运算符的优先级比`*`的优先级高，因此`()`括号外面的函数名会被解析为函数名，而不会被解析为函数指针。

  函数指针还可以和关键字`typedef`相结合，从而将一些含有函数指针的复杂语句进行简化，比如下面的复杂语句：

  ```c
  void (*signal(int signo, void (*func)(int)))(int);
  ```

  这条语句和`int (*pfunc)(int, int);`相比还是复杂了不少的，两个这也有一定的区别：

  - `int (*pfunc)(int, int);`语句定义了一个函数指针，其变量名为`pfunc`，这个函数指针只能指向返回值是`int`，并且两个参数也是`int`的函数。
  - `void (*signal(int signo, void (*func)(int)))(int);`语句则定义了一个返回值是函数指针的函数，注意**这是定义的一个函数而不是函数指针**，这个函数的函数名为`signal`，有两个参数，第一个是一个`int`类型的变量，第二个是一个函数指针（只能指向返回值为空，参数是`int`类型的函数），其返回值是一个函数指针（只能指向返回值为空，参数是`int`类型的函数）。

  通过观察可以发现两者的区别还是很明显的，第一个语句的变量名后面没有函数运算符`()`，而第二个语句后面有函数运算符`()`，由于函数运算符`()`比指针运算符`*`优先级高，因此第二个语句的变量名，很明显是一个函数名而不是一个变量名。

  可以通过`typedef`语句来将`void (*signal(int signo, void (*func)(int)))(int);`语句进行简化，`typedef`可以如下所示：

  ```c
  typedef void Sigfunc(int);
  ```

  上面语句中的`Sigfunc`并不是一个变量而是一个类型，类似于`typedef long int REAL;`语句（该语句可以使用REAL代替`long int`来定义一个该类型的变量），其可以用`Sigfunc`来声明一个函数（返回值为`void`，参数为`int`的函数，注意不是函数指针），由此可以将返回函数指针的函数`void (*signal(int signo, void (*func)(int)))(int);`函数进行简化，简化的具体步骤如下：

  - 通过观察，可以将其第二个参数`void (*func)(int)`进行简化，从而得到`Sigfunc *func`（`Sigfunc`是一个函数的类型，而`func`是一个函数指针，因此要加`*`号）。
  - `signal`函数的返回值是一个函数指针类型（返回值为`void`，参数为`int`的函数），因此也可以用`typedef`定义的函数类型`Sigfunc`来进行简化，简化之后的结果为`Sigfunc *signal`。

  于是得到最终的结果：

  ```c
  Sigfunc *signal(int signo, Sigfunc *func);
  ```

- 关于Linux中的signal信号的相关总结：

  程序在运行过程中，**用`ctrl + c`、`kill`命令以及`killall`命令的本质**就是向正在运行的程序发送信号。

  signal信号是**进程之间相互传递消息的一种方法**，信号全称为软中断信号，也有人称作**软中断**，从它的命名可以看出，它的**实质和使用很像中断**。

  软中断信号（signal，又简称为信号）用来**通知进程发生了事件**。**进程之间可以通过调用kill库函数发送软中断信号**。**Linux内核也可能给进程发送信号**，通知进程发生了某个事件（例如内存越界）。注意，信号只是用来通知某进程发生了什么事件，**无法给进程传递任何数据**，进程对信号的处理办法有三种：

  - 第一种方法是，忽略某个信号，对该信号不做任何处理，就像未发生过一样。
  - 第二种是设置中断的处理函数，收到信号后，由该函数来处理。
  - 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。

  信号有很多种类别，对于不同的信号有着不同缺省处理；在程序中可以编写相关的信号处理的代码对信号进行捕获，还可以编写信号处理函数，进行收到信号后的一系列处理操作。下面是一些常用信号的总结：

  | 信号名  | 信号值   | 默认处理动作                                                 | 发出信号的原因                                   |
  | ------- | -------- | ------------------------------------------------------------ | ------------------------------------------------ |
  | SIGINT  | 2        | 终止进程                                                     | 键盘中断Ctrl+c                                   |
  | SIGKILL | 9        | 终止进程，且信号不能被捕获也不能被忽略。                     | 采用kill  -9 进程编号 强制杀死程序。             |
  | SIGSEGV | 11       | 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。 | 无效的内存引用                                   |
  | SIGTERM | 15       | 终止进程                                                     | 采用“kill  进程编号”或“killall 程序名”通知程序。 |
  | SIGCHLD | 20,17,18 | 忽略此信号，将该信号丢弃，不做处理。                         | 子进程结束信号                                   |

  信号从大体上可以分为两类：

  - 不可靠信号（Linux中的编号范围是：1-32）：

    主要有两类问题：

    - 如果给不可靠信号设置了处理函数，每次处理完信号后，程序中设置的处理函数将失效，下次再处理该信号时，将会采取默认的处理方式（这类问题是就版本的Linux系统中存在的，**现在的系统已经不存在这种问题了**）。

    - 会存在信号丢失的问题，即相同的信号多次到来，会被合并成一个。测试如下：

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <signal.h>
      #include <unistd.h>
      
      void sig_handler(int);
      
      int main() {
          signal(15, sig_handler);
          signal(34, sig_handler);
          int i = 0;
          while(1) {
              printf("main fuc start %ds\n", ++i);
              sleep(1);
          }
          return 0;
      }
      
      // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
      void sig_handler(int signum) {
          int i = 0;
          printf("sig %d will maintain 5s\n", signum);
          while(i < 5) {
              printf("Sig %d comming for %ds\n", signum, ++i);
              sleep(1);
          }
      }
      ```

      执行的动图如下所示：

      ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_sig_reliable.gif)

  - 可靠信号（Linux中的编号范围是：34-64）：发送连续的信号的时候不会发生信号的丢失。

  关于信号处理函数被中断的问题讨论：

  - 如果在执行某个信号的处理函数的过程中，遇到了**同种信号**的到来，那么后面到来的信号会被阻塞（可以理解为是**排队**），等到之前的处理函数处理完毕之后，才会执行被阻塞的信号的处理函数（如果是不可靠信号，连续的发送可能会造成信号的丢失）。
  - 如果在执行某个信号的处理函数的过程中，遇到了**另外的信号**的到来，那么后面到来的信号会将当前正在执行的处理函数中断，转而执行新到来的信号的处理函数（可以理解为**插队**），处理完毕后，再去之后之前的处理函数。

  测试如下：

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <signal.h>
  #include <unistd.h>
  
  void sig_handler(int);
  
  int main() {
      signal(15, sig_handler);
      signal(34, sig_handler);
      int i = 0;
      while(1) {
          printf("main fuc start %ds\n", ++i);
          sleep(1);
      }
      return 0;
  }
  
  // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
  void sig_handler(int signum) {
      int i = 0;
      printf("sig handle fuc %d will maintain 5s\n", signum);
      while(i < 5) {
          printf("Sig %d comming for %ds\n", signum, ++i);
          sleep(1);
      }
  }
  ```

  对应的执行动图如下：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_sig_interrupt.gif)

  关于信号的阻塞问题的讨论：

  **如果不希望在接到信号的时候中断当前的处理函数**，也不希望忽略该信号，而是延时一段时间再处理这个信号，可以通过**阻塞信号**来实现。

  信号的阻塞和忽略信号是不同的，**被阻塞的信号**，不会影响系统的行为，只是**被暂时阻止了传递**；如果信号被忽略，信号会被传递给进程，但进程处理这个信号的方式是将其丢弃。

  由此信号就有了两种状态，一种是信号递达（Deliver），即正在执行关于信号的处理动作，另一种相对的就是信号未决（Pending），即信号从产生到递达之间的状态，信号被阻塞就是出于这种Pending状态。

  如何实现信号阻塞？
  
  先要了解几个函数：
  
  ```c
  #include <signal.h>
  
  int sigemptyset(sigset_t *set);									// 清空一个信号集
  																// 第一个参数是信号集
  
  int sigfillset(sigset_t *set);									// 将Linux中全部的信号加入到信号集中
  																// 第一个参数是信号集
  
  int sigaddset(sigset_t *set, int signum);						// 将某一个信号加入到信号集中
  																// 第一个参数是信号集，第二个参数待加入信号集的信号
  
  int sigdelset(sigset_t *set, int signum);						// 将某一个信号从信号集中删除
  																// 第一个参数是信号集，第二个参数待从信号集中删除的信号
  
  int sigismember(const sigset_t *set, int signum);				// 查看一个信号是否在信号集中
  																// 第一个参数是信号集，第二个参数是待判断存在性的信号
  
  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);// 对信号集进行一些操作
  																// 第一个参数是操作动作的指定，如果是SIG_BLOCK是将第二个参数对应的信号集进行阻塞，如果是SIG_UNBLOCK，则是将第二个参数指定的信号集去小阻塞
  ```
  
  下面是针对信号阻塞进行相关的测试：
  
  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <signal.h>
  #include <unistd.h>
  
  void sig_common_handler(int);
  void sig15_handler(int);
  void sig34_handler(int);
  
  
  int main() {
      signal(15, sig15_handler);
      signal(34, sig34_handler);
      int i = 0;
      while(1) {
          printf("main fuc start %ds\n", ++i);
          sleep(1);
      }
      return 0;
  }
  
  void sig15_handler(int signum) {
      /* 核心 */
      sigset_t set;                           // 定义一个信号集
      sigemptyset(&set);                      // 清空一个信号集
      sigaddset(&set, 34);                    // 将信号34加入到信号集中
      sigprocmask(SIG_BLOCK, &set, NULL);     // 将信号集中的信号阻塞
      /* 核心 */
      sig_common_handler(signum);
  }
  
  void sig34_handler(int signum) {
      sig_common_handler(signum);
  }
  
  // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
  void sig_common_handler(int signum) {
      int i = 0, maintain_sec = 10;
      printf("sig handle fuc %d will maintain %ds\n", signum, maintain_sec);
      while(i < maintain_sec) {
          printf("Sig %d comming for %ds\n", signum, ++i);
          sleep(1);
      } 
  }
  ```
  
  下面是对上面代码的演示：
  
  ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_sig_block.gif)
  
  如何设置针对某种信号的处理函数？
  
  有两种方式：
  
  - 使用`signal`函数来进行设置：
  
    函数原型如下：
  
    ```c
    #include <signal.h>
    
    typedef void (*sighandler_t)(int);
    
    sighandler_t signal(int signum, sighandler_t handler);
    ```
  
    下面是对该函数进行的测试：
  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    
    void sigint_handler(int);
    
    int main() {
        signal(SIGINT, sigint_handler);
        while(1) {
            printf("waiting for SIGINT signal\n");
            sleep(2);
        }
        return 0;
    }
    
    // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
    void sigint_handler(int signum) {
        printf("SIGINT comming, its signum is %d\n", signum);
    }
    ```
  
    根据上面的代码可知，`signal`函数的第二个参数就是信号处理函数（即上面代码中的`sigint_handler`函数），这个信号处理函数有一个参数一定是`int`类型，用来获取`linux`系统中信号的数字编号是多少？下面是上图代码执行的动图展示：
  
    ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_signal_fuc.gif)
    
  - 使用`sigaction`来实现信号处理函数的设置以及信号阻塞的设置
  
    首先来看看函数原型，和相关的结构体原型：
  
    ```c
    #include <signal.h>
    
    struct sigaction {
        void     (*sa_handler)(int);							// 函数指针，指向信号处理函数
        void     (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t   sa_mask;										// 信号集
        int        sa_flags;									// 标志位（下面会讲解SA_RESTART）
    	void     (*sa_restorer)(void);
    };
    
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
    ```
  
    下面是相关的测试代码：
  
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    #include <string.h>
    typedef void (*pfuc_f_sig)(int);
    
    void sig_common_handler(int);
    void sigaction_init(struct sigaction *act);                                 // 一定要第一个执行
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler);    // 一定要最后执行, 如果先执行了该语句之后再设置阻塞队列或者标志等成员，可能不会生效
    void set_sig_mask(struct sigaction *act, int signum_f_mask);
    void set_sig_flag(struct sigaction *act, int sa_flags);
    
    
    int main() {
        // signal(15, sig15_handler);
        // signal(34, sig34_handler);
        struct sigaction act_f_15, act_f_34;
        /* 配置信号15的处理函数 */
        sigaction_init(&act_f_15);
        set_sig_mask(&act_f_15, 34); // 将信号34添加到信号15的阻塞队列中
        set_sig_fuc(15, &act_f_15, sig_common_handler); // 给信号15设置处理函数
        /* 配置信号15的处理函数 */
        /* 配置信号34的处理函数 */
        sigaction_init(&act_f_34);
        set_sig_fuc(34, &act_f_34, sig_common_handler); // 给信号34设置处理函数
        /* 配置信号34的处理函数 */
        int i = 0;
        while(1) {
            printf("main fuc start %ds\n", ++i);
            sleep(1);
        }
        return 0;
    }
    
    void sigaction_init(struct sigaction *act) {
        memset(act, 0, sizeof(struct sigaction));
    }
    
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler) {
        act->sa_handler = handler;
        sigaction(signum, act, NULL);
        return ;
    }
    
    void set_sig_mask(struct sigaction *act, int signum) {
        sigaddset(&act->sa_mask, signum);
    }
    
    // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
    void sig_common_handler(int signum) {
        int i = 0, maintain_sec = 10;
        printf("sig handle fuc %d will maintain %ds\n", signum, maintain_sec);
        while(i < maintain_sec) {
            printf("Sig %d comming for %ds\n", signum, ++i);
            sleep(1);
        } 
    }
    
    void set_sig_flag(struct sigaction *act, int sa_flags) {
        act->sa_flags |= sa_flags;
    }
    ```
    
    下面是关于上面代码的演示：
    
    ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_sigaction.gif)
    
    下面来讨论一下标志，只讨论标志`SA_RESTART`。
    
    当某个进程正在执行某种系统调用时，如果此时有信号到达，会**终止**当前的系统调用，当信号对应的处理结束之后不会重启刚刚被信号终止的系统调用，如果设置了标志`SA_RESTART`，那么会将刚刚被信号终止的系统调用重启。下面是对`scanf`这种系统调用就行测试。
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    #include <string.h>
    typedef void (*pfuc_f_sig)(int);
    
    void sig_common_handler(int);
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler);
    void set_sig_mask(struct sigaction *act, int signum_f_mask);
    void set_sig_flag(struct sigaction *act, int sa_flags);
    
    int main() {
        // signal(15, sig15_handler);
        // signal(34, sig34_handler);
        struct sigaction act_f_15;
        set_sig_fuc(15, &act_f_15, sig_common_handler); // 给信号15设置处理函数
        // set_sig_flag(&act_f_15, SA_RESTART);
        int i = 0;
        while(i == 0) {
            printf("main fuc start \n");
            scanf("%*s");
            i++;
        }
        return 0;
    }
    
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler) {
        memset(act, 0, sizeof(act));
        act->sa_handler = handler;
        sigaction(signum, act, NULL);
        return ;
    }
    
    void set_sig_mask(struct sigaction *act, int signum) {
        sigaddset(&act->sa_mask, signum);
    }
    
    // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
    void sig_common_handler(int signum) {
        int i = 0, maintain_sec = 10;
        printf("sig handle fuc %d will maintain %ds\n", signum, maintain_sec);
        while(i < maintain_sec) {
            printf("Sig %d comming for %ds\n", signum, ++i);
            sleep(1);
        } 
    }
    
    void set_sig_flag(struct sigaction *act, int sa_flags) {
        act->sa_flags |= sa_flags;
    }
    ```
    
    下面是关于上面代码的测试：
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>
    #include <string.h>
    typedef void (*pfuc_f_sig)(int);
    
    void sig_common_handler(int);
    void sigaction_init(struct sigaction *act);
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler);
    void set_sig_mask(struct sigaction *act, int signum_f_mask);
    void set_sig_flag(struct sigaction *act, int sa_flags);
    
    int main() {
        // signal(15, sig15_handler);
        // signal(34, sig34_handler);
        struct sigaction act_f_15;
        /* 核心 */
        sigaction_init(&act_f_15);                      // 一定要第一个执行
        set_sig_flag(&act_f_15, SA_RESTART);
        set_sig_fuc(15, &act_f_15, sig_common_handler); // 给信号15设置处理函数, 一定要最后执行, 如果先执行了该语句之后再设置阻塞队列或者标志等成员，可能不会生效
        /* 核心 */
        int i = 0;
        while(i == 0) {
            printf("main fuc start \n");
            char str[100005];
            scanf("%s", str);
            printf("str=%s\n", str);
            i++;
        }
        return 0;
    }
    
    void sigaction_init(struct sigaction *act) {
        memset(act, 0, sizeof(struct sigaction));
    }
    
    void set_sig_fuc(int signum, struct sigaction *act, pfuc_f_sig handler) {
        act->sa_handler = handler;
        sigaction(signum, act, NULL);
        return ;
    }
    
    void set_sig_mask(struct sigaction *act, int signum) {
        sigaddset(&act->sa_mask, signum);
    }
    
    // 此处的信号处理函数只有一个参数，是int类型，表示信号在Linux系统中的编号
    void sig_common_handler(int signum) {
        int i = 0, maintain_sec = 10;
        printf("sig handle fuc %d will maintain %ds\n", signum, maintain_sec);
        while(i < maintain_sec) {
            printf("Sig %d comming for %ds\n", signum, ++i);
            sleep(1);
        } 
    }
    
    void set_sig_flag(struct sigaction *act, int sa_flags) {
        act->sa_flags |= sa_flags;
    }
    ```
    
    下面是关于上面代码的动图演示：
    
    ![](D:\for_wps\WPS Cloud Files\typora_imags\test_for_syscall_restart.gif)

- 关于在vmware上开两个虚拟机使用socket进行通信时错误【connect error: No route to host】的解决方案：

  首先需要将两个虚拟机的网络配置设置为NAT，将虚拟机vmware当作是路由器，操作如下图：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\vmware_set_nat.gif)

  之后检查两个虚拟机是否属于一个内网（运算方法是将IP地址和子网掩码做与运算），操作如下：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\vmware_check_Intranet.gif)

  将两个系统中的防火墙关闭，通过命令`systemctl stop firealld.service`。之后两个虚拟机就可以进行用socket进行通信了，效果如下图所示：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\vmware_test_socket.gif)

- 关于在数据存储方式不同的主机上分别运行客户端和服务端程序，进行数值数据的传输时发生的问题讨论（对应书中的练习5.8）。

  客户端和服务端实现的功能是客户端给服务端发送两个数值，服务端将这两个数值相加后给客户端，我的的机器上只有小端存储的系统，**弄一个大端存储的系统比较麻烦，于是用下面的程序来进行模拟**：

  ```c
  #include <stdio.h>
  #include <arpa/inet.h>
  #include <limits.h>
  
  int main() {
      int first_num;
      int second_num;
      while(scanf("%d %d", &first_num, &second_num) != EOF) {
          printf("DEC: %d\n", (int)ntohl((int)htonl(first_num) + (int)htonl(second_num)));
          printf("HEX: %x\n\n", (int)ntohl((int)htonl(first_num) + (int)htonl(second_num)));
      }
      return 0;
  }
  ```

  其中`(int)htonl(first_num) + (int)htonl(second_num)`用来模拟在大端服务器中进行加法操作，最外层的`ntohl`函数是模拟小端客户端接收的结果（**当然这个程序不一定对**）。

  假设客户端是小端存储，服务端是大端存储（反过来是一样的）；

  客户端向服务端发送数值`0x00 00 00 10`和`0x00 00 00 20`，数据到达了大端存储方式的服务端会被解释为`0x01 00 00 00`和`0x02 00 00 00`，两者相加就是`0x03 00 00 00`，之后服务端将结果回传给客户端，客户端会将结果解析为`0x00 00 00 30`，**虽然这两个正数相加没有问题**，但是不代表所有的正数相加都没有问题，**下面是通过上面的程序测试的结果**：

  ```
  1 2
  DEC: 3
  HEX: 3
  
  100 200
  DEC: 44
  HEX: 2c
  
  400000 200000
  DEC: 600000
  HEX: 927c0
  
    
  ```

  可以发现`100 + 200 `的结果就不对，原因是在大端服务系统相加高位溢出被丢弃了，**所以只要是存在溢出的情况，正数相加的结果都不会对**。

  **下面来讨论负数的情况**，假设客户端向服务端传送的两个数值分别为-1和-2，由于数值类型是通过机器补码的形式存储在内存中的，因此这两个数值在内存中为`0xff ff ff ff`和`0xff ff ff fe`，数据到达了服务端会被解释为`0xff ff ff ff`以及`0x fe ff ff ff`，两者相加的结果为`0xfe ff ff fe`，传回到客户端会被解析为`0xfe ff ff fe`，即`-16777218`，**从这可以看出负数的结果基本上多不对**。

- 关于客户端和服务端主机分别在32位系统和64位系统运行时，进行数值数据的传输发生问题的讨论（对应书中的练习5.10）。

  客户端和服务端实现的功能是客户端给服务端发送两个数值，服务端将这两个数值相加后给客户端

  假设数值数据是通过下面的结构体进行传输：

  ```c
  struct args { // 两个待相加的数
      long arg1;
      long arg2;
  };
  
  struct result { // 两个数相加后的结果
      long sum;
  };
  ```

  假设客户端读写数据的语句分别为`Readn(sockfd, &result, sizeof(result)`和`Writen(sockfd, &args, sizeof(args))`。服务端的读写数据语句分别为` Readn(sockfd, &args, sizeof(args))`和`Writen(sockfd, &result, sizeof(result));`。

  有两种情况：

  - 客户端是32位机器，服务端是64位机器：

    客户端会将两个32位的long数值通过结构体的形式一次性发送给服务端，但是由于服务端是64位，因此服务端期望获得两个64位的数值，由于客户端发送的字节数达不到服务端`Readn`函数的要求，所以服务端会阻塞在函数`Readn`直到获得了期望的字节数。

  - 客户端是64位机器，服务端是32位机器：

    客户端会将两个64位的long数值通过结构体的形式一次性发送给服务器，但是由于服务器是32位，期望获得的是两个32位的数值，因此它会将客户端发送的第一个64位数值解读成两个32位进行加法运算，将第二个64位数值进行丢弃，返回给客户端的也是一个32位的数值，由于没有达到客户端`Readn`要求的字节数，所以客户端会永远阻塞在`Readn`。

### 6、Multiplexing: The select and poll Functions

- 为了方便起见，把使用`select`函数的`str_cli`函数放在下面（Figure 6.9）：

  ```c
  1  #include	"unp.h"
  
  2  void
  3  str_cli(FILE *fp, int sockfd)
  4  {
  5 	  int			maxfdp1;
  6 	  fd_set		rset;
  7 	  char		sendline[MAXLINE], recvline[MAXLINE];
  
  8 	  FD_ZERO(&rset);
  9     for ( ; ; ) {
  10		  FD_SET(fileno(fp), &rset);
  11		  FD_SET(sockfd, &rset);
  12		  maxfdp1 = max(fileno(fp), sockfd) + 1;
  13		  Select(maxfdp1, &rset, NULL, NULL, NULL);
  
  14		  if (FD_ISSET(sockfd, &rset)) {	/* socket is readable */
  15		  	  if (Readline(sockfd, recvline, MAXLINE) == 0)
  16				  err_quit("str_cli: server terminated prematurely");
  17			  Fputs(recvline, stdout);
  18		  }
  
  19		  if (FD_ISSET(fileno(fp), &rset)) {  /* input is readable */
  20			  if (Fgets(sendline, MAXLINE, fp) == NULL)
  21				  return;		/* all done */
  22			  Writen(sockfd, sendline, strlen(sendline));
  23		  }
  24	  }
  25 }
  ```

- 下面放出一个我所理解的客户端和服务端通过TCP server进行交互的图（不一定对）：

  ![image-20210714141925911](D:\for_wps\WPS Cloud Files\typora_imags\image-20210714141925911.png)

- 关于`shutdown`函数和`close`函数的小总结（对应于练习6.6）：`shutdown`总是发送FIN，`close`是先将socket关闭，再发送FIN。

- 关于低潮限度（low-water mark）的说明：

  低潮限度是否可以理解为是一个阈值，如果数据没达到这个阈值就不读，如果缓冲区没达到这个阈值就不能写入。

  比如，如果应用只有在数据大于64字节的时候才会进行一些处理，那么就把低潮限度设置为64字节，数据不够64字节，就不让select将应用唤醒。

  We can set this low-water mark using the SO_SNDLOWAT socket option. This low-water mark normally defaults to 2048 for TCP and UDP sockets.

- 关于使用`select`函数实现IO复用的相关说明。

  概述：如果程序中使用了`select`函数，当程序执行到`select`函数的时候，会被阻塞，这就**带来了一个好处**：程序不会因为某种特定的IO而被阻塞，取而代之的是先在`select`函数处阻塞，等待某些特定的描述符（由用户通过参数的方式向`select`函数指定）具备读写等能力的时候，程序会从`select`函数的阻塞中苏醒，进而可以对这些具备读写等能力的描述字进行相应的处理。

  上面的概述可能有些抽象，下面来通过经典的echo客户端-服务端程序来进行说明，首先假设客户端的核心处理程序如下（省略了建立connect socket的过程，在书中对应的位置是Figure 5.5）：

  ```c
  #include	"unp.h"
  
  void
  str_cli(FILE *fp, int sockfd)
  {
  	char	sendline[MAXLINE], recvline[MAXLINE];
  
  	while (Fgets(sendline, MAXLINE, fp) != NULL) {
  
  		Writen(sockfd, sendline, strlen(sendline));
  
  		if (Readline(sockfd, recvline, MAXLINE) == 0)
  			err_quit("str_cli: server terminated prematurely");
  
  		Fputs(recvline, stdout);
  	}
  }
  ```

  上面程序的大概过程是：先通过`Fgets`函数从stdio buffer中读取一行数据，之后调用`Write`函数将其写入到TCP 客户端的发送缓冲区，然后调用`Readline`函数从TCP 客户端的接收缓冲区读取数据，最后通过`Fputs`将服务端反馈的数据输出到标准输出。

  这个程序看上去条例还算是必将清晰，不过还是会**存在问题**的，比如，在客户端因`Fgets`函数等待标准输入而陷入阻塞的时候，如果**服务端进程突然挂掉了**，服务端进程会向TCP 客户端socket发送一个FIN，紧接着TCP 客户端会向服务端发送这个FIN的ACK，**按照正常的处理过程**，客户端应该向服务端服务端发送FIN并且接收来自服务端的ACK，双方正常结束的，**可是**客户端一直被`Fgets`函数所阻塞，只有当客户端执行到后面的`Readline`函数的时候才能处理服务端发送过来的FIN，让客户端和服务端的connect正常结束，**因此**为了不让程序因`Fgets`造成的阻塞而耽误了更为重要的connect termination，可以使用**`select`函数改写**上面的写法，如下：

  ```c
  #include	"unp.h"
  
  void
  str_cli(FILE *fp, int sockfd)
  {
  	int			maxfdp1;
  	fd_set		rset;
  	char		sendline[MAXLINE], recvline[MAXLINE];
  
  	FD_ZERO(&rset);
  	for ( ; ; ) {
  		FD_SET(fileno(fp), &rset);
  		FD_SET(sockfd, &rset);
  		maxfdp1 = max(fileno(fp), sockfd) + 1;
  		Select(maxfdp1, &rset, NULL, NULL, NULL);
  
  		if (FD_ISSET(sockfd, &rset)) {	/* socket is readable */
  			if (Readline(sockfd, recvline, MAXLINE) == 0)
  				err_quit("str_cli: server terminated prematurely");
  			Fputs(recvline, stdout);
  		}
  
  		if (FD_ISSET(fileno(fp), &rset)) {  /* input is readable */
  			if (Fgets(sendline, MAXLINE, fp) == NULL)
  				return;		/* all done */
  			Writen(sockfd, sendline, strlen(sendline));
  		}
  	}
  }
  ```

  当然上面的代码在批量文件输入的时候是有问题的，不过这些暂时先不进行讨论；**上面的代码处理过程如下**：程序执行之后会阻塞在`Select`函数处，直到第二个参数（可读描述符集合）中至少有一个描述符具备了可读性，程序就会从`Select`函数中苏醒，接下来就可以对这些具备可读性的描述符进行处理，上面的`Select`函数的第二个参数可读描述符集中有两个descriptor，一个是stdio buffer对应的descriptor，一个是TCP客户端receive buffer对应的descriptor，如果stdio descriptor可读，那么说明用户进行了标准输入，如果TCP客户端receive buffer descriptor可读，那么说明服务端给客户端发送了数据，这样就**很好的解决了之前程序阻塞**在`Fgets`而没有马上正常结束的问题，**假设服务端进程崩溃了**，服务端向客户端发送FIN，客户端回馈了一个ACK进行确认，之后TCP客户端receive buffer存在数据，TCP客户端receive buffer descriptor可读（一般当存储的数据大于之前总结的low-water mark时，对应的descriptor可读，此处不考虑数据是否大于low-water mark），而stdio buffer不存在数据，因此stdio buffer descriptor不可读，所以程序从`Select`函数的阻塞中苏醒之后，会执行`Readline`函数让客户端也正常结束，而不会在`Fgets`被阻塞。

- 使用`setrlimit`函数给进程设置可以打开的描述符个数（对应练习6.4）

  首先来看一下`setrlimit`的函数原型：

  ```c
  #include <sys/time.h>
  #include <sys/resource.h>
  
  struct rlimit {
      rlim_t rlim_cur;  /* Soft limit */
      rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
  };
  
  int getrlimit(int resource, struct rlimit *rlim);
  int setrlimit(int resource, const struct rlimit *rlim);
  ```

  `setrlimit`的第一个参数用来指定要设置的资源，此处我们需要设置进程能够打开的描述符个数，给第一个参数传`RLIMIT_NOFILE`就可以，第二个参数是一个结构体，第一个成员用来指定软限制，第二个成员用来控制硬限制，如果超过了硬限制，就会报错。`getrlimit`用来查看某个资源的限制。

  两个函数都是执行成功返回0，执行失败返回-1。

  将`setrlimit`函数应用到服务端的程序，如下所示：

  ```c
  /* include fig01 */
  #include <sys/time.h>
  #include <sys/resource.h>
  #include	"unp.h"
  
  int
  main(int argc, char **argv)
  {
      struct rlimit new_rlim, empty_rlim;
      new_rlim.rlim_cur = 5;
      new_rlim.rlim_max = 5;
      setrlimit(RLIMIT_NOFILE, &new_rlim);
      int result = getrlimit(RLIMIT_NOFILE, &empty_rlim);
      printf("result: %d\n", result);
      printf("cur: %d, max: %d\n", empty_rlim.rlim_cur, empty_rlim.rlim_max);
  	int					i, maxi, maxfd, listenfd, connfd, sockfd;
  	int					nready, client[FD_SETSIZE];
  	ssize_t				n;
  	fd_set				rset, allset;
  	char				buf[MAXLINE];
  	socklen_t			clilen;
  	struct sockaddr_in	cliaddr, servaddr;
  
  	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
      printf("sdfsd\n");
  
  	bzero(&servaddr, sizeof(servaddr));
  	servaddr.sin_family      = AF_INET;
  	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  	servaddr.sin_port        = htons(SERV_PORT);
  
  	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
  
  	Listen(listenfd, LISTENQ);
  
  	maxfd = listenfd;			/* initialize */
  	maxi = -1;					/* index into client[] array */
  	for (i = 0; i < FD_SETSIZE; i++)
  		client[i] = -1;			/* -1 indicates available entry */
  	FD_ZERO(&allset);
  	FD_SET(listenfd, &allset);
  /* end fig01 */
  
  /* include fig02 */
  	for ( ; ; ) {
  		rset = allset;		/* structure assignment */
  		nready = Select(maxfd+1, &rset, NULL, NULL, NULL);
  
  		if (FD_ISSET(listenfd, &rset)) {	/* new client connection */
  			clilen = sizeof(cliaddr);
  			connfd = Accept(listenfd, (SA *) &cliaddr, &clilen);
  #ifdef	NOTDEF
  			printf("new client: %s, port %d\n",
  					Inet_ntop(AF_INET, &cliaddr.sin_addr, 4, NULL),
  					ntohs(cliaddr.sin_port));
  #endif
  
  			for (i = 0; i < FD_SETSIZE; i++)
  				if (client[i] < 0) {
  					client[i] = connfd;	/* save descriptor */
  					break;
  				}
  			if (i == FD_SETSIZE)
  				err_quit("too many clients");
  
  			FD_SET(connfd, &allset);	/* add new descriptor to set */
  			if (connfd > maxfd)
  				maxfd = connfd;			/* for select */
  			if (i > maxi)
  				maxi = i;				/* max index in client[] array */
  
  			if (--nready <= 0)
  				continue;				/* no more readable descriptors */
  		}
  
  		for (i = 0; i <= maxi; i++) {	/* check all clients for data */
  			if ( (sockfd = client[i]) < 0)
  				continue;
  			if (FD_ISSET(sockfd, &rset)) {
  				if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {
  						/*4connection closed by client */
  					Close(sockfd);
  					FD_CLR(sockfd, &allset);
  					client[i] = -1;
  				} else
  					Writen(sockfd, buf, n);
  
  				if (--nready <= 0)
  					break;				/* no more readable descriptors */
  			}
  		}
  	}
  }
  /* end fig02 */
  ```

  如上程序，将打开的文件描述的软硬限制都设置成5，如果程序打开的文件描述符超过了5个，那么就会报错。下面是对这个程序的测试，如下：

  ![](D:\for_wps\WPS Cloud Files\typora_imags\test_f_setrlimit.gif)

  下面补充一下上面使用的`lsof`命令的两个常用用法：

  ```shell
  lsof filename # 查看某个文件打开的进程
  lsof -p pid # 查看某个进程打开的描述符
  cat /proc/pid/fd # 也能查看进程打开的描述符
  ```

  标准输入、标准输出以及标准错误分别对应的描述符为0，1，2。

### 7、Socket Options

- 为了方便起见，这里放一个TCP Output的模型（Figure 2.15）：

  ![image-20210717113545790](D:\for_wps\WPS Cloud Files\typora_imags\image-20210717113545790.png)

- 为了方便起见，下面放上一个检测各种TCP条件的方法的图（Figure 7.6），**同时也是对`SO_KEEPALIVE`选项的**总结：

  ![image-20210716152939727](D:\for_wps\WPS Cloud Files\typora_imags\image-20210716152939727.png)

  上面的存活选项是socket选项中的`SO_KEEPALIVE`。进程崩溃，TCP服务还没有崩溃因此可以发送出FIN，主机崩溃的话，TCP服务也会崩溃，因此连FIN都发送不出来。

- 为了方便起见，下面放上一个`close`函数、`shutdown`函数以及`SO_LINGER`选项的总结（Figure 7.12）：

  ![image-20210723111256897](D:\for_wps\WPS Cloud Files\typora_imags\image-20210723111256897.png)

- 打印TCP、UDP、STCP三个协议的发送/接收缓冲区大小：

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <sys/time.h>
  #include <netinet/in.h> 
  #include <arpa/inet.h>
  #include <string.h>
  #include <time.h>
  
  union val {
    int				i_val;
    long				l_val;
    struct linger		linger_val;
    struct timeval	timeval_val;
  } val;
  
  static char	*sock_str_int(union val *, int);
  
  struct sock_opts {
    const char	   *opt_str;
    int		opt_level;
    int		opt_name;
    char   *(*opt_val_str)(union val *, int);
  } sock_opts[] = {
  	{ "SO_RCVBUF",			SOL_SOCKET,	SO_RCVBUF,		sock_str_int },
  	{ "SO_SNDBUF",			SOL_SOCKET,	SO_SNDBUF,		sock_str_int },
  	{ NULL,					0,			0,				NULL }
  };
  
  int main() {
      p_proto_buf_sz("tcp");
      p_proto_buf_sz("udp");
      p_proto_buf_sz("sctp");
      return 0;
  }
  
  void p_proto_buf_sz(char *proto_name) {
      struct sock_opts *ptr;
      for(ptr = sock_opts; ptr->opt_str != NULL; ptr++) {
          int fd;
          if(strcmp(proto_name, "tcp") == 0) {
              fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
          } else if(strcmp(proto_name, "udp") == 0) {
              fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
          } else if(strcmp(proto_name, "sctp") == 0) {
              fd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP);
          }
          int len;
          len = sizeof(val);
          getsockopt(fd, ptr->opt_level, ptr->opt_name, &val, &len);
          printf("protocol name: %s\n", proto_name);
          printf("%s: %s\n", ptr->opt_str, ptr->opt_val_str(&val, len));
      }
      printf("\n");
  }
  
  
  static char	strres[128];
  
  static char	*
  sock_str_int(union val *ptr, int len)
  {
  	if (len != sizeof(int))
  		snprintf(strres, sizeof(strres), "size (%d) not sizeof(int)", len);
  	else
  		snprintf(strres, sizeof(strres), "%d", ptr->i_val);
  	return(strres);
  }
  ```

- 关于`nagle`算法和delay ack的说明（同时总结练习7.8、7.9的答案）：

  `https://blog.51cto.com/littledevil/1966546`;

  `https://blog.51cto.com/u_15144024/2840605?xiangguantuijian&01`;

###　8、Elementary UDP Sockets

- 为了方便起见，附上一个UDP客户端服务端的流程图（Figure 8.1）：

  ![image-20210801095809595](D:\for_wps\WPS Cloud Files\typora_imags\image-20210801095809595.png)

- 如果一个TCP接收缓冲区有4096B的数据，UDP接收缓冲区有2个2048B的数据报，前者使用read函数一次读取4096B，后者使用recvfrom函数也一次读取4096B，两者有什么不同（对应练习8.1）。

  read函数会一次性读取4096B的数据，而recvfrom函数一次**只读取**一个数据报。

- 小总结（对应练习8.2）：一般sendto函数的最后一个参数（地址长度len）使用的是recvfrom函数执行过后的len。

  ![image-20210730220617242](D:\for_wps\WPS Cloud Files\typora_imags\image-20210730220617242.png)

### 9、Elementary SCTP Sockets

- 为了方便起见，附上一个SCTP一对一的模型（Figure 9.1）：

  ![image-20210801100336105](D:\for_wps\WPS Cloud Files\typora_imags\image-20210801100336105.png)

- 为了方便起见，附上一个SCTP一对多的模型（Figure 9.2）：

  ![image-20210801100433568](D:\for_wps\WPS Cloud Files\typora_imags\image-20210801100433568.png)

### 10、SCTP Client/Server Example

- 如何控制一个网卡的丢包率？

  可以参考这边博客：`https://www.cnblogs.com/dwdw/p/12681870.html`。

  也可参考命令`sudo tc qdisc add dev ens33 root netem loss 40%`，这个命令是控制网卡的丢包率在40%左右。如下图。

  ![image-20210806170936714](D:\for_wps\WPS Cloud Files\typora_imags\image-20210806170936714.png)
  
- 关于SCTP服务端应用程序突然崩溃以及服务端主机突然崩溃，客户端程序会有什么样的反应的讨论，此处就不再赘述，和TCP的测试是相同的，先使用命令`tcpdump`打开包的监听，使用`kill`命令关闭服务端应用程序模拟服务端程序突然关闭的情况，服务端主机突然崩溃可以使用突然关机来模拟。

### 11、Name and Address Conversions

- 将一台Ubuntu18.04的机器（`ip`为`192.168.1.144`）配置成内网DNS服务器，并在客户端机器（`ip`为`192.168.1.143`）上进行测试：

  - 服务端机器（`ip`为`192.168.1.144`）需要进行的配置：

    - 安装`bind9`：

      ```shell
      sudo apt update
      sudo apt install bind9 bind9utils bind9-doc
      ```

    - 修改配置文件`/etc/bind/named.conf.options`，内容如下：

      ```
      acl "trusted" {
              192.168.1.0/24;
      };
      
      options {
      	directory "/var/cache/bind";
          recursion yes;
          allow-recursion { trusted; };
          listen-on { 192.168.1.144; };
          allow-transfer { none; };
          forwarders {
                  114.114.114.114;
          };
      	// If there is a firewall between you and nameservers you want
      	// to talk to, you may need to fix the firewall to allow multiple
      	// ports to talk.  See http://www.kb.cert.org/vuls/id/800113
      
      	// If your ISP provided one or more IP addresses for stable 
      	// nameservers, you probably want to use them as forwarders.  
      	// Uncomment the following block, and insert the addresses replacing 
      	// the all-0's placeholder.
      
      	// forwarders {
      	// 	0.0.0.0;
      	// };
      
      	//========================================================================
      	// If BIND logs error messages about the root key being expired,
      	// you will need to update your keys.  See https://www.isc.org/bind-keys
      	//========================================================================
      	dnssec-validation auto;
      
      	auth-nxdomain no;    # conform to RFC1035
      	listen-on-v6 { any; };
      };
      ```

      上面内容的部分含义解释如下：

      - `acl`部分：`acl`是控制哪些客户端可以连接到这个 `DNS` 上的，支持子网掩码方式，例子中我把 `192.168.1.0/24` 网段中的所有 `IP` 都设为了可访问。

      - `recursion` 字段：设置成 `yes`，表示允许递归 `DNS` 查询。
      - `allow-recursion` 字段：允许递归查询的客户端范围，这里设置成了之前在 `acl` 中声明的 `trusted`。
      - `listen-on` 字段：表示 `DNS` 服务监听在哪个地址上，填写本地 `IP` 即可。
      - `allow-transfer` 字段：设置成 none 表示不允许其他 `DNS` 服务器从本 `DNS` 服务器中查询。
      - `forwarders` 字段：原因是我们的内网 `DNS` 服务只提供了很有限的几条 `DNS` 记录，如果不做点什么的话，APT 源的地址都解析不了。`BIND9` 提供 `DNS` 查询的转发机制，当本地 `DNS` 查询不到，将查询转发到 forwarders 上，并把查询结果缓存到本地 `DNS` 上，这样问题就解决了。本文使用的是国内公网 `DNS：114.114.114.114`，大家可以根据自己的需求进行修改。

    - 下面拿配置域名`yyy.com`来进行测试：

      - 修改配置文件`/etc/bind/named.conf.local`如下：

        ```shell
        //
        // Do any local configuration here
        //
        
        // Consider adding the 1918 zones here, if they are not used in your
        // organization
        //include "/etc/bind/zones.rfc1918";
        
        zone "yyy.com" { 
             type master; 
             file "/etc/bind/db.yyy.com";  // 这个文件需要创建并进行一些修改
        }; 
           
        zone "1.168.192.in-addr.arpa" { 
             type master; 
             file "/etc/bind/db.yyy.192.168.1"; // 这个文件需要创建并进行一些修改
        }; 
        ```

      - 修改 `zone`文件

        创建文件`/etc/bind/db.yyy.com`，并进行编辑，如下（最好是使用`cp`命令复制已经存在的`zone`文件，这样可以保证权限是正确的）：

        ```
        ; 
        ; BIND data file for dev sites 
        ; 
        $TTL    604800 
        @       IN      SOA     testing.yyy.com. admin.yyy.com. ( 
                                      2         ; Serial 
                                 604800         ; Refresh 
                                  86400         ; Retry 
                                2419200         ; Expire 
                                 604800 )       ; Negative Cache TTL 
        ; 
        @       IN      NS      epc.yyy.com. 
        yyy.com.       IN      NS      epc.yyy.com. 
        ; 下面给epc.yyy.com.这个域名添加多个客户端地址
        epc.yyy.com.  14400   IN      A       192.168.1.143
        epc.yyy.com.  14400   IN      A       192.168.1.142
        epc.yyy.com.  14400   IN      A       192.168.1.141
        testing.yyy.com.  14400   IN      A       192.168.1.143
        yyy.com.  14400   IN      A       192.168.1.143
        cn.yyy.com.  14400   IN      AAAA      2409:8a50:2650:efb0:8d4a:8975:5f70:63c8
        abc.yyy.com.    14400   IN  A   1.1.1.1
        cname   CNAME   epc
        ```

        上面的`A`记录是设置域名对应的`IPv4`地址，`AAAA`记录时设置对应的`IPv6`地址，`CNAME`记录是设置域名对应的别名。

        创建文件`/etc/bind/db.yyy.192.168.1`，并进行编辑，如下（最好是使用`cp`命令复制已经存在的`zone`文件，这样可以保证权限是正确的）：

        ```
        ; 
        ; BIND reverse data file for dev domains 
        ; 
        $TTL    604800 
        @       IN      SOA     dev. root.dev. ( 
                                      1         ; Serial 
                                 604800         ; Refresh 
                                  86400         ; Retry 
                                2419200         ; Expire 
                                 604800 )       ; Negative Cache TTL 
        ; 
        @        IN      NS      yyy.com. 
        143      IN      PTR     yyy.com. 
        ```

      上面的文件是反射文件，最后一行的`PTR`记录用来指定`192.168.1.143`对应的是`yyy.com`这个域名。

      如果判断上面文件是否有错误可以通过执行下面的命令来进行验证：

      ```shell
      sudo named-checkconf
      sudo named-checkzone 域名 文件名
      ```

      PS：每修改一次上面的文件都要重启一下`bind9`服务，通过命令`service bind9 restart`。

  - 配置完上面的服务端机器后，可以配置客户端机器（`ip`为`192.168.1.143`）进行验证：

    - 修改配置文件`/etc/systemd/resolved.conf`，如下：

      ```
      #  This file is part of systemd.
      #
      #  systemd is free software; you can redistribute it and/or modify it
      #  under the terms of the GNU Lesser General Public License as published by
      #  the Free Software Foundation; either version 2.1 of the License, or
      #  (at your option) any later version.
      #
      # Entries in this file show the compile time defaults.
      # You can change settings by editing this file.
      # Defaults can be restored by simply deleting this file.
      #
      # See resolved.conf(5) for details
      
      [Resolve]
      DNS=192.168.1.144 114.114.114.114 8.8.8.8
      #FallbackDNS=
      #Domains=
      #LLMNR=no
      #MulticastDNS=no
      #DNSSEC=no
      #Cache=yes
      #DNSStubListener=yes
      ```

      原本`DNS`选项是被注释掉的，上面配置了三个`DNS`服务器，第一个是配置的内网`DNS`。

      使用命令`systemctl restart systemd-resolved`重启域名解析服务。

      使用命令`systemd-resolve --status`查看结果如下：

      ```shell
      Global
               DNS Servers: 192.168.1.144
                            114.114.114.114
                            8.8.8.8
      ```

      这样就算是客户端机器配置成功了。

    - 将文件`/etc/resolv.conf`改成指向`/run/systemd/resolve/resolv.conf`的符号链接，如果已经建立了，就不需要再重复建立了。

- 下面总结一些关于计算机网络的一些基础知识：

  只要设备能够通过网卡连接上网络就会被分配一个`IP`地址。

  网络可以粗略的分为：

  - 内网（局域网）：
    - 同一局域网下处于相同网段的计算机可以进行通信（比如socket）。判断两台计算机是否处于同一网段可以通过将`IP`与子网掩码进行与运算，看是否相同来判断。
    - 同一局域网下处于不同网段的计算机不能进行通信，除非使用了NAT技术进行`IP`地址的转换。
    - 不同局域网下的`IP`处于不同的网段，即便是通过`IP`与子网掩码进行计算之后的结果相同也不属于同一个网段。
    - 不同局域网下可以存在相同的`IP`。
    - 一般内网`IP`是`10.xxx.xxx.xxx`和`192.168.xxx.xxx`。
  - 外网（公网）：全球唯一的`IP`，可以被其他接入因特网的设备所访问，即便与这些这些设备处于不同的局域网也能够被访问。

- 为了方便起见，这里放上一个`hostent`结构：

  ```c
  struct hostent {
  	char *h_name; 		/* official (canonical) name of host */
  	char **h_aliases; 	/* pointer to array of pointers to alias names */
  	int h_addrtype; 	/* host address type: AF_INET */
  	int h_length; 		/* length of address: 4 */
  	char **h_addr_list; /* ptr to array of ptrs with IPv4 addrs */
  };
  ```

  `gethostbyname`和`gethostbyaddr`这两个函数的返回值都是上面的结构体。这两个函数当前的版本不支持`IPv6`地址。如果要使用`IPv6`地址，可以使用函数`getaddrinfo`进行替换。

  其中`h_addr_list`存储的是网络字节序。

- 为了方便起见，这里放上一个`servent`结构：

  ```c
  struct servent {
      char *s_name; 		/* official service name */
      char **s_aliases; 	/* alias list */
      int s_port; 		/* port number, network-byte order */
      char *s_proto; 		/* protocol to use */
  };
  ```

  `getservbyname`和`getservbyport`这两个函数的返回值都是上面的结构体，

- 为了方便起见，这里放上一个`addrinfo`结构：

  ```c
  struct addrinfo {
      int ai_flags; 				/* AI_PASSIVE, AI_CANONNAME */
      int ai_family; 				/* AF_xxx */
      int ai_socktype; 			/* SOCK_xxx */
      int ai_protocol; 			/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
      socklen_t ai_addrlen; 		/* length of ai_addr */
      char *ai_canonname; 		/* ptr to canonical name for host */
      struct sockaddr *ai_addr; 	/* ptr to socket address structure */
      struct addrinfo *ai_next; 	/* ptr to next structure in linked list */
  };
  ```

  这个结构是函数`getaddrinfo`的返回值。

  下面放上一个`freebsd4` 的规范名称是 `freebsd4.unpbook.com` 并且该主机在 `DNS` 中有两个 `IPv4` 地址时，下面语句的返回值：

  ```c
  struct addrinfo hints, *res;
  bzero(&hints, sizeof(hints));
  hints.ai_flags = AI_CANONNAME;						// 保证返回的第一个addrinfo结构时含有规范主机名的
  hints.ai_family = AF_INET;
  getaddrinfo("freebsd4", "domain", &hints, &res);
  ```

  结果如下图：

  ![image-20210811145420303](D:\for_wps\WPS Cloud Files\typora_imags\image-20210811145420303.png)

  为了方便起见，下面顺便附上一个根据指定的服务名称（可以是十进制端口号）和任何 `ai_socktype` 提示为每个返回的地址返回的 `addrinfo` 结构的数量。

  ![image-20210811145556213](D:\for_wps\WPS Cloud Files\typora_imags\image-20210811145556213.png)

  为了方便起见，下图总结了我们期望 `getaddrinfo` 如何处理 `IPv4` 和 `IPv6` 地址。 给定前三列中的变量（通过`hints`来指定），“result”列是我们想要返回给调用者的内容。  “Action”列是我们如何获得此结果的方式：

  ![image-20210811170336120](D:\for_wps\WPS Cloud Files\typora_imags\image-20210811170336120.png)

  上图中第一列中的`passive`表示调用者使用`socket`是被动使用，`active`表示主动使用。

- 关于`malloc`函数和`free`函数的说明：

  使用`malloc`申请的内存并不会在编译的时候进行分配，而是在程序运行执行到调用`malloc`的时候才会向内存进行空间申请，等这一部分空间用完之后，系统是不会自动将这部分空间返还给内存的，因此需要使用`free`函数进行手动返还（有借有还），如果不这么做，会导致内存泄露。

- 关于网关、DNS、子网掩码、MAC地址的简介见博客`http://www.360doc.com/content/19/0424/14/37015604_831140294.shtml`。

  关于`ipv6`地址`ping`不同的问题所在见博客`https://www.cnblogs.com/qijunzifeng/p/13753185.html`。
  
  只有`ipv6`地址是`Global`才能不指定端口直接`ping`通，如果是`Link`就是不能直接`ping`通的，如下图：
  
  ![image-20210822113728212](D:\for_wps\WPS Cloud Files\typora_imags\image-20210822113728212.png)

- 下面总结一些关于将函数`recvfrom`返回的源地址参数应用于`gethostbyaddr`函数的一些注意事项（对应练习11.6）：

  首先先看一下`recvfrom`的原型：

  ```c
  #include <sys/types.h>
  #include <sys/socket.h>
  
  ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                   struct sockaddr *src_addr, socklen_t *addrlen);
  ```

  对于上面的参数`src_addr`的类型是一个通用地址结构体类型，保存着源地址信息，如果知道这个地址是`ipv4`的话可以通过以下语句将一个`struct sockaddr *`类型的变量解析成`ipv4`地址结构体来使用。

  ```c
  struct sockaddr_in *ipv4_addr = (struct sockaddr_in *) src_addr; // src_addr类型为通用地址struct sockaddr *
  ```

  再来看看`gethostbyaddr`函数的原型：

  ```c
  #include <netdb.h>
  
  struct hostent *gethostbyaddr(const void *addr,
                                socklen_t len, int type);
  ```

  第一个参数是一个指向一个地址信息的指针，拿`ipv4`来举例，在调用该函数的时候传入的是`struct in_addr`这个结构体变量的地址，`len`是这个`ipv4`地址结构体的大小，可以使用函数`sizeof`获得，`type`是地址族类型，对于`ipv4`来说的话就是`AF_INET`。

  最后来看看`gethostbyaddr`函数如何运用`recvfrom`的参数`src_addr`，代码如下：

  ```c
  struct sockaddr_in *ipv4_addr = (struct sockaddr_in *) src_addr; // src_addr类型为通用地址struct sockaddr *
  struct hostent *aptr;
  if((aptr = gethostbyaddr(&ipv4_addr->sin_addr, sizeof(ipv4_addr->sin_addr), AF_INET)) == NULL) {
  	printf("gethostbyaddr error\n");
      exit(0);
  }
  ```

  从上面的代码可以看出`gethostbyaddr`函数的第一个参数是地址的网络字节序，因为`struct in_addr`这个结构存储的就是网络字节序，**因此在使用`gethostbyaddr`函数的时候一定要将地址字符串转变成网络字节序作为该函数的第一个参数**。

### 12、IPv4 and IPv6 Interoperability

- 将一台`ubuntu18.04`的机器配置成`ftp`服务器：

  先安装`vsftpd`：

  ```shell
  sudo apt install vsftpd
  ```

  为`ftp`服务器创建一个用户：

  ```shell
  sudo adduser userftp
  ```

  修改配置文件`/etc/vsftpd.conf`：

  ```shell
  sudo vim /etc/vsftpd.conf
  
  # 文件内容如下：
  # Example config file /etc/vsftpd.conf
  #
  # The default compiled in settings are fairly paranoid. This sample file
  # loosens things up a bit, to make the ftp daemon more usable.
  # Please see vsftpd.conf.5 for all compiled in defaults.
  #
  # READ THIS: This example file is NOT an exhaustive list of vsftpd options.
  # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's
  # capabilities.
  #
  #
  # Run standalone?  vsftpd can run either from an inetd or as a standalone
  # daemon started from an initscript.
  listen=NO
  #
  # This directive enables listening on IPv6 sockets. By default, listening
  # on the IPv6 "any" address (::) will accept connections from both IPv6
  # and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6
  # sockets. If you want that (perhaps because you want to listen on specific
  # addresses) then you must run two copies of vsftpd with two configuration
  # files.
  listen_ipv6=YES
  #
  # Allow anonymous FTP? (Disabled by default).
  anonymous_enable=NO
  #
  # Uncomment this to allow local users to log in.
  local_enable=YES
  #
  # Uncomment this to enable any form of FTP write command.
  #write_enable=YES
  #
  # Default umask for local users is 077. You may wish to change this to 022,
  # if your users expect that (022 is used by most other ftpd's)
  #local_umask=022
  #
  # Uncomment this to allow the anonymous FTP user to upload files. This only
  # has an effect if the above global write enable is activated. Also, you will
  # obviously need to create a directory writable by the FTP user.
  #anon_upload_enable=YES
  #
  # Uncomment this if you want the anonymous FTP user to be able to create
  # new directories.
  #anon_mkdir_write_enable=YES
  #
  # Activate directory messages - messages given to remote users when they
  # go into a certain directory.
  dirmessage_enable=YES
  #
  # If enabled, vsftpd will display directory listings with the time
  # in  your  local  time  zone.  The default is to display GMT. The
  # times returned by the MDTM FTP command are also affected by this
  # option.
  use_localtime=YES
  #
  # Activate logging of uploads/downloads.
  xferlog_enable=YES
  #
  # Make sure PORT transfer connections originate from port 20 (ftp-data).
  connect_from_port_20=YES
  #
  # If you want, you can arrange for uploaded anonymous files to be owned by
  # a different user. Note! Using "root" for uploaded files is not
  # recommended!
  #chown_uploads=YES
  #chown_username=whoever
  #
  # You may override where the log file goes if you like. The default is shown
  # below.
  #xferlog_file=/var/log/vsftpd.log
  #
  # If you want, you can have your log file in standard ftpd xferlog format.
  # Note that the default log file location is /var/log/xferlog in this case.
  #xferlog_std_format=YES
  #
  # You may change the default value for timing out an idle session.
  #idle_session_timeout=600
  #
  # You may change the default value for timing out a data connection.
  #data_connection_timeout=120
  #
  # It is recommended that you define on your system a unique user which the
  # ftp server can use as a totally isolated and unprivileged user.
  #nopriv_user=ftpsecure
  #
  # Enable this and the server will recognise asynchronous ABOR requests. Not
  # recommended for security (the code is non-trivial). Not enabling it,
  # however, may confuse older FTP clients.
  #async_abor_enable=YES
  #
  # By default the server will pretend to allow ASCII mode but in fact ignore
  # the request. Turn on the below options to have the server actually do ASCII
  # mangling on files when in ASCII mode.
  # Beware that on some FTP servers, ASCII support allows a denial of service
  # attack (DoS) via the command "SIZE /big/file" in ASCII mode. vsftpd
  # predicted this attack and has always been safe, reporting the size of the
  # raw file.
  # ASCII mangling is a horrible feature of the protocol.
  #ascii_upload_enable=YES
  #ascii_download_enable=YES
  #
  # You may fully customise the login banner string:
  #ftpd_banner=Welcome to blah FTP service.
  #
  # You may specify a file of disallowed anonymous e-mail addresses. Apparently
  # useful for combatting certain DoS attacks.
  #deny_email_enable=YES
  # (default follows)
  #banned_email_file=/etc/vsftpd.banned_emails
  #
  # You may restrict local users to their home directories.  See the FAQ for
  # the possible risks in this before using chroot_local_user or
  # chroot_list_enable below.
  #chroot_local_user=YES
  #
  # You may specify an explicit list of local users to chroot() to their home
  # directory. If chroot_local_user is YES, then this list becomes a list of
  # users to NOT chroot().
  # (Warning! chroot'ing can be very dangerous. If using chroot, make sure that
  # the user does not have write access to the top level directory within the
  # chroot)
  chroot_local_user=YES
  chroot_list_enable=YES
  # (default follows)
  chroot_list_file=/etc/vsftpd.chroot_list # 配置允许登录ftp的用户
  #
  # You may activate the "-R" option to the builtin ls. This is disabled by
  # default to avoid remote users being able to cause excessive I/O on large
  # sites. However, some broken FTP clients such as "ncftp" and "mirror" assume
  # the presence of the "-R" option, so there is a strong case for enabling it.
  #ls_recurse_enable=YES
  #
  # Customization
  #
  # Some of vsftpd's settings don't fit the filesystem layout by
  # default.
  #
  # This option should be the name of a directory which is empty.  Also, the
  # directory should not be writable by the ftp user. This directory is used
  # as a secure chroot() jail at times vsftpd does not require filesystem
  # access.
  secure_chroot_dir=/var/run/vsftpd/empty
  #
  # This string is the name of the PAM service vsftpd will use.
  pam_service_name=vsftpd
  #
  # This option specifies the location of the RSA certificate to use for SSL
  # encrypted connections.
  rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
  rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
  ssl_enable=NO
  
  #
  # Uncomment this to indicate that vsftpd use a utf8 filesystem.
  #utf8_filesystem=YES
  #userlist_deny=NO
  #userlist_enable=YES
  #userlist_file=/etc/allowed_users # 配置允许访问ftp的用户
  #seccomp_sandbox=NO
  local_root=/home/userftp
  #local_enable=YES
  #write_enable=YES
  #utf8_filesystem=YES
  ```

  可以使用`diff -u`来进行比较看看我修改了什么内容。

  创建允许访问的用户列表：

  ```shell
  sudo vim /etc/vsftpd.chroot_list
  
  # 可以将自己电脑中的用户添加进去，比如我电脑中的用户：
  userftp
  testvim
  ```

  检查禁止访问名单：

  ```c
  sudo vim /etc/ftpusers
      
  # 内容如下：
  # /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5).
  
  root
  daemon
  bin
  sys
  sync
  games
  man
  lp
  mail
  news
  uucp
  nobody
  ```

  接下来验证配好的`ftp`；

  重启服务器：

  ```shell
  sudo /etc/init.d/vsftpd restart
  ```

  验证是否配置成功：

  - 在windows上进行验证如下：

    首先打开此电脑，访问`ftp`服务器，如下图：

    ![image-20210824161358595](D:\for_wps\WPS Cloud Files\typora_imags\image-20210824161358595.png)

    输入用户名和密码即可登录，如下：

    ![image-20210824161450550](D:\for_wps\WPS Cloud Files\typora_imags\image-20210824161450550.png)

    ![image-20210824161500146](D:\for_wps\WPS Cloud Files\typora_imags\image-20210824161500146.png)

  - 在`ubuntu`上验证，如下：

    ![image-20210824161617669](D:\for_wps\WPS Cloud Files\typora_imags\image-20210824161617669.png)

- 为了方便起见，放上一个`IPv4` 和 `IPv6` 客户端和服务器之间的互操作性摘要（Figure 12.5）。

  ![image-20210823144211648](D:\for_wps\WPS Cloud Files\typora_imags\image-20210823144211648.png)

  如果组合正常，则每个框包含“`IPv4`”或“`IPv6`”，指示使用哪种协议，如果组合无效，则包含“（no）”。 最后一行的第三列标有星号（“（no*）”），因为互操作性取决于客户端选择的地址。 选择 `AAAA` 记录并发送 `IPv6` 数据报将不起作用。 但是选择作为 `IPv4` 映射 `IPv6` 地址返回给客户端的 `A` 记录会导致发送 `IPv4` 数据报，这将起作用。 通过遍历 `getaddrinfo` 返回的所有地址，我们可以确保我们将尝试 `IPv4` 映射的 `IPv6` 地址。

  尽管表中的五个条目似乎不会互操作，但在可预见的未来，在现实世界中，`IPv6` 的大多数实现将在双栈主机上实现，而不会是纯 `IPv6` 实现。 因此，如果我们删除第二行和第二列，所有“(no)”条目都会消失，唯一的问题是带有星号（“（no*）”）的条目。

### 13、Daemon Processes and the inetd Super server

- 为了方便起见，下面附上一个`inetd`服务进程的执行流程：

  ![image-20210825204215150](D:\for_wps\WPS Cloud Files\typora_imags\image-20210825204215150.png)

  上面的文件`/etc/inetd.conf`现如今已经变成了`/etc/xinetd.conf`文件以及目录`/etc/xinetd.d/`中的文件了。

  如果我们更详细地查看正在发生的描述符处理，下图显示了当来自 `FTP` 客户端的新连接请求到达时 `inetd` 中的描述符：

  ![image-20210825204635933](D:\for_wps\WPS Cloud Files\typora_imags\image-20210825204635933.png)

  连接请求被定向到 TCP 端口 21，但接受创建了一个新的连接套接字。

  下图显示了在调用 `fork` ，子进程关闭了除连接的套接字之外的所有描述符之后。子进程中的描述符：

  ![image-20210825204959896](D:\for_wps\WPS Cloud Files\typora_imags\image-20210825204959896.png)

  下一步是让孩子将连接的套接字复制到描述符 0、1 和 2，然后关闭连接的套接字，如下图：

  ![image-20210825205126392](D:\for_wps\WPS Cloud Files\typora_imags\image-20210825205126392.png)

  然后孩子调用exec，所有描述符通常在 exec 中保持打开状态，因此被执行的真实服务器使用描述符 0、1 或 2 中的任何一个来与客户端通信。 这些应该是服务器中唯一打开的描述符。

- 关于Linux会话组和进程组的说明，见博客`https://www.cnblogs.com/zhangming-blog/articles/5955544.html`。

  当会话领导者终止时，会话中的所有进程都会收到`SIGHUP`信号。

- 在进行将程序（`inetd/daytimetcpsrv2.c`）改成守护进程的过程中发现守护进程与客户端进行通信时产生的log并没有按照书中说的写入到文件`/var/log/messages`中，于是我使用命令`sudo ack -w "connection from" .`进行查看，发现log写入到了文件`/var/log/syslog`中，查询资料后发现需要进行配置（`https://blog.csdn.net/feinifi/article/details/107037892`），如下：

  修改文件`/etc/rsyslog.d/50-default.conf`，增加一行`*.info;mail.none;authpriv.none;cron.none        /var/log/messages`

  之后通过命令`systemctl restart rsyslog.service`重新加载配置，重启成功后，就会发现已经有`messages`这个文件了。

- 如何将自己的程序添加到`xinetd`中：

  首先将自己的服务名`mydaytime`、协议以及端口添加到文件`/etc/services`的最后一行。如下所示：

  ```
  mydaytime   9999/tcp    # test for unp
  ```

  之后编写服务相关的配置文件放入目录`/etc/xinetd.d/`中，操作如下：

  ```shell
  sudo cp -rp /etc/xinetd.d/daytime /etc/xinetd.d/mydaytime
  sudo vim /etc/xinetd.d/mydaytime
  ```

  配置文件内容如下：

  ```
  # default: on
  # description: An internal xinetd service which gets the current system time
  # then prints it out in a format like this: "Wed Nov 13 22:30:27 EST 2002".
  # This is the tcp version.
  
  service   mydaytime
  {
    disable   =   no
    # 此处用端口9999来作测试
    port   =   9999
    socket_type   =   stream
    protocol   =   tcp
    user   =   root
    # 下面的server选项填写的是服务的可执行文件
    server   =   /home/testvim/unix_network_programming/unpv13e/inetd/daytimetcpsrv3
    type   =   UNLISTED
    wait   =   no
  }
  ```

  之后重启`xinetd`服务，如下：

  ```shell
  sudo /etc/init.d/xinetd restart
  ```

  通过命令`netstat -na | grep 9999`进行测试，出现如下内容说明成功了：

  ```shell
  tcp6       0      0 :::9999                 :::*                    LISTEN
  ```

### 14、Advanced I/O Functions

- 为了方便起见，下面附上结构体`msghdr`：

  ```c
  struct iovec {
      void *iov_base; /* starting address of buffer */
      size_t iov_len; /* size of buffer */
  };
  
  struct msghdr {
      void *msg_name; /* protocol address (eg: sockaddr_in{}) */
      socklen_t msg_namelen; /* size of protocol address */
      struct iovec *msg_iov; /* scatter/gather array */
      int msg_iovlen; /* # elements in msg_iov */
      void *msg_control; /* ancillary data (cmsghdr struct) */
      socklen_t msg_controllen; /* length of ancillary data */
      int msg_flags; /* flags returned by recvmsg() */
  };
  ```

  上面的`cmsghdr`结构是用来存储辅助数据的，如下：

  ```c
  struct cmsghdr {
      socklen_t cmsg_len; /* length in bytes, including this structure */
      int cmsg_level; /* originating protocol */
      int cmsg_type; /* protocol-specific type */
  /* followed by unsigned char cmsg_data[] */
  };
  ```

  辅助数据的用途总结如下（Figure 14.11）：

  ![image-20210901142926885](D:\for_wps\WPS Cloud Files\typora_imags\image-20210901142926885.png)

  下图显示了辅助数据`*msg_control`指向的辅助数据结构示例（Figure 14.12）：

  ![image-20210901144627621](D:\for_wps\WPS Cloud Files\typora_imags\image-20210901144627621.png)

  `msg_control` 指向第一个辅助数据对象，辅助数据的总长度由`msg_controllen` 指定。 每个对象前面都有一个描述该对象的 `cmsghdr` 结构。  `cmsg_type` 成员和实际数据之间可以有填充（`pad`），也可以在数据的末尾、下一个辅助数据对象之前有填充。下面的宏是对辅助数据的操作函数：

  ```c
  #include <sys/socket.h>
  #include <sys/param.h> /* for ALIGN macro on many implementations */
  
  struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *mhdrptr);
  							Returns: pointer to first cmsghdr structure or NULL if no ancillary data
  struct cmsghdr *CMSG_NXTHDR(struct msghdr *mhdrptr, struct cmsghdr *cmsgptr);
  							Returns: pointer to next cmsghdr structure or NULL if no more ancillary data objects
  unsigned char *CMSG_DATA(struct cmsghdr *cmsgptr);
  							Returns: pointer to first byte of data associated with cmsghdr structure
  unsigned int CMSG_LEN(unsigned int length);
  							Returns: value to store in cmsg_len given the amount of data
  unsigned int CMSG_SPACE(unsigned int length);
  							Returns: total size of an ancillary data object given the amount of data
  ```

  下面的代码是对上面五个宏的使用范例：

  ```c
  struct msghdr msg;
  struct cmsghdr *cmsgptr;
  /* fill in msg structure */
  /* call recvmsg() */
  for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;
      cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {
      if (cmsgptr->cmsg_level == ... &&
      cmsgptr->cmsg_type == ... ) {
          u_char *ptr;
          ptr = CMSG_DATA(cmsgptr);
          /* process data pointed to by ptr */
  	} 
  }
  ```

  `CMSG_FIRSTHDR` 返回指向第一个辅助数据对象的指针，如果 `msghdr` 结构中没有辅助数据，则返回空指针（`msg_control` 是空指针或 `cmsg_len` 小于 `cmsghdr` 结构的大小）。 当控制缓冲区中没有其他辅助数据对象时，`CMSG_NXTHDR` 返回空指针。

- 为了方便起见，附上一个五组 I/O 功能之间的差异图（Figure 14.10）。

  ![image-20210831210616116](D:\for_wps\WPS Cloud Files\typora_imags\image-20210831210616116.png)

  上面图中的列分了三组进行对比。

- 关于`c`语言中`open`函数的第三个参数`mode`的说明，见博客`https://blog.csdn.net/ArchyLi/article/details/78937937`，如果指定`mode`为`0`，表示没有打开的文件没有任何权限，`mode`和`linux`中的`umask`有关。

- 关于语句`result = Ioctl(wfd, DP_POLL, &dopoll);`的说明：Ioctl对于DP_POLL这个请求的返回值应是准备好的文件描述符数量，用result来保存，这些文件描述符通过`struct dvpoll`的“参数-值”的形式进行返回。

  ```c
  struct dvpoll {
      struct pollfd* dp_fds;
      int dp_nfds;
      int dp_timeout;
  }
  
  struct pollfd {
      int fd; /* descriptor to check */
      short events; /* events of interest on fd */
      short revents; /* events that occurred on fd */
  };
  ```
  
  文件描述符存储在成员`dp_fds`中。

- 关于标准IO的全缓冲、行缓冲、无缓冲的说明见博客：`https://blog.csdn.net/weixin_34273046/article/details/86458224`。

  C/C++中，基于I/O流的操作最终会调用系统接口`read()`和`write()`完成I/O操作。为了使程序的运行效率最高，流对象通常会提供
  缓冲区,以减少调用系统I/O接口的调用次数。缓冲方式存在三种，分别是:

  - 全缓冲。输入或输出缓冲区被填满才会进行实际I/O操作。其他情况，如强制刷新、进程结束也会进行实际I/O操作。
    对于读操作来说，当读入内容的字节数等于缓冲区大小、或者文件已经到达结尾、或者强制刷新，会进行实际的I/O操作,将外
    存文件内容读入缓冲区；对于写操作来说，当缓冲区被填满或者强制刷新，会进行实际的I/O操作，缓冲区内容写到外存文件
    中。磁盘文件操作通常是全缓冲的。
  - 行缓冲。输入或输出缓冲区遇到换行符会进行实际I/O操作。其他与全缓冲相同。
  - 无缓冲。没有缓冲区,数据会立即读入内存或者输出到外存文件和设备上。标准错误输出`stderr`是无缓冲的，这样能够
    保证错误信息及时反馈给用户，供用户排除错误。

  补充对`fllush`函数的说明：
  定义函数：`int fflush(FILE * stream);`
  函数说明：`fflush`会强迫将缓冲区内的数据写回参数`stream`指定的文件中，如果参数`stream`为`NULL`，`fflush`会将所有打开的文件数据更新。
  `stdin`是`standard input`的缩写，即标准输入，一般是指键盘；标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区。`stdout`是`standard output` 的缩写，即标准输出，一般是指显示器；标准输出缓冲区即是用来暂存将要显示的内容的缓冲区。

- `c`语言中`read`和`write`函数是系统调用，由操作系统来进行的IO操作，其他的设计IO操作的c库函数都是对这两个系统调用的封装。
- 查询某个套接字接收缓冲区有多少字节的数据可以通过语句`Ioctl(sockfd, FIONREAD, &npend);`，结果保存在`npend`中，不过有一点需要注意，有可能ioctl返回的字节数为0，原因是数据还没有传送到接收缓冲区，因此可以延时一定的时间再调用ioctl就有结果了（对应练习14.3）。更为详细的关于ioctl函数的说明见`https://www.cnblogs.com/zxc2man/p/9511856.html`。

